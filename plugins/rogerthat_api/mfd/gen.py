#!/usr/bin/env python
# @@xxx_skip_license@@
# -*- coding: utf-8 -*-
# @PydevCodeAnalysisIgnore

# copied from https://github.com/our-city-app/mobicage-backend/blob/master/src/rogerthat/bizz/service/mfd/gen.py

import base64
import sys

import datetime as datetime_
import re as re_
import warnings as warnings_

try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_

Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc


def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#


try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')

        class _FixedOffsetTZ(datetime_.tzinfo):

            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name

            def utcoffset(self, dt):
                return self.__offset

            def tzname(self, dt):
                return self.__name

            def dst(self, dt):
                return None

        def gds_format_string(self, input_data, input_name=''):
            return input_data

        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data

        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)

        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data

        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values

        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')

        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values

        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data

        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values

        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()

        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)

        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0',):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values

        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue

        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"),)
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt

        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue

        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()

        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data

        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue

        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1

        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()

        def gds_str_lower(self, instring):
            return instring.lower()

        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path

        Tag_strip_pattern_ = re_.compile(r'\{.*\}')

        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)

        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1

        def gds_build_any(self, node, type_name=None):
            return None

        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))

        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring

        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__

        def __ne__(self, other):
            return not self.__eq__(other)

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

# # from IPython.Shell import IPShellEmbed
# # args = ''
# # ipshell = IPShellEmbed(args,
# #     banner = 'Dropping into IPython',
# #     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name,))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline,)
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8

    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value

    def getCategory(self):
        return self.category

    def getContenttype(self, content_type):
        return self.content_type

    def getValue(self):
        return self.value

    def getName(self):
        return self.name

    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:  # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)

    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))

    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:  # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)

    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text

    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:  # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):

    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional

    def set_name(self, name): self.name = name

    def get_name(self): return self.name

    def set_data_type(self, data_type): self.data_type = data_type

    def get_data_type_chain(self): return self.data_type

    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type

    def set_container(self, container): self.container = container

    def get_container(self): return self.container

    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs

    def get_child_attrs(self): return self.child_attrs

    def set_choice(self, choice): self.choice = choice

    def get_choice(self): return self.choice

    def set_optional(self, optional): self.optional = optional

    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class AlertIntervalType(object):
    NONE = 'NONE'
    INTERVAL__5 = 'INTERVAL_5'
    INTERVAL__15 = 'INTERVAL_15'
    INTERVAL__30 = 'INTERVAL_30'
    INTERVAL__60 = 'INTERVAL_60'
    INTERVAL__300 = 'INTERVAL_300'
    INTERVAL__900 = 'INTERVAL_900'
    INTERVAL__3600 = 'INTERVAL_3600'


class AlertType(object):
    BEEP = 'BEEP'
    SILENT = 'SILENT'
    RING__5 = 'RING_5'
    RING__15 = 'RING_15'
    RING__30 = 'RING_30'
    RING__60 = 'RING_60'


class FormButton(object):
    POSITIVE = 'positive'
    NEGATIVE = 'negative'


class KeyboardType(object):
    DEFAULT = 'DEFAULT'
    AUTO_CAPITALIZED = 'AUTO_CAPITALIZED'
    EMAIL = 'EMAIL'
    URL = 'URL'
    PHONE = 'PHONE'
    NUMBER = 'NUMBER'
    DECIMAL = 'DECIMAL'
    PASSWORD = 'PASSWORD'
    NUMBER_PASSWORD = 'NUMBER_PASSWORD'


class MemberStatus(object):
    SUBMITTED = 'SUBMITTED'
    INITIATED = 'INITIATED'
    RUNNING = 'RUNNING'
    FINISHED = 'FINISHED'


class ProgrammingLanguage(object):
    JYTHON = 'JYTHON'
    JRUBY = 'JRUBY'


class Attachment(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, name=None, url=None, contentType=None, size=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.url = _cast(None, url)
        self.contentType = _cast(None, contentType)
        self.size = _cast(int, size)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Attachment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Attachment.subclass:
            return Attachment.subclass(*args_, **kwargs_)
        else:
            return Attachment(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_name(self): return self.name

    def set_name(self, name): self.name = name

    def get_url(self): return self.url

    def set_url(self, url): self.url = url

    def get_contentType(self): return self.contentType

    def set_contentType(self, contentType): self.contentType = contentType

    def get_size(self): return self.size

    def set_size(self, size): self.size = size

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='Attachment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Attachment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Attachment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Attachment', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Attachment'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.url), input_name='url')),))
        if self.contentType is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            outfile.write(' contentType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.contentType), input_name='contentType')),))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Attachment', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
        value = find_attr_value_('contentType', node)
        if value is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            self.contentType = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Attachment


class FlowElement(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowElement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowElement.subclass:
            return FlowElement.subclass(*args_, **kwargs_)
        else:
            return FlowElement(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_id(self): return self.id

    def set_id(self, id): self.id = id

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='FlowElement', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlowElement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowElement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='FlowElement', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlowElement'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='FlowElement', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FlowElement


class Answer(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, caption=None, action=None, id=None, reference=None, color=None):
        self.original_tagname_ = None
        self.caption = _cast(None, caption)
        self.action = _cast(None, action)
        self.id = _cast(None, id)
        self.reference = _cast(None, reference)
        self.color = _cast(None, color)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Answer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Answer.subclass:
            return Answer.subclass(*args_, **kwargs_)
        else:
            return Answer(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_caption(self): return self.caption

    def set_caption(self, caption): self.caption = caption

    def get_action(self): return self.action

    def set_action(self, action): self.action = action

    def get_id(self): return self.id

    def set_id(self, id): self.id = id

    def get_reference(self): return self.reference

    def set_reference(self, reference): self.reference = reference

    def get_color(self): return self.color

    def set_color(self, color): self.color = color

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='Answer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Answer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Answer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Answer', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Answer'):
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caption), input_name='caption')),))
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.action), input_name='action')),))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')),))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')),))
        if self.color is not None and 'color' not in already_processed:
            already_processed.add('color')
            outfile.write(' color=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.color), input_name='color')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Answer', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
        value = find_attr_value_('color', node)
        if value is not None and 'color' not in already_processed:
            already_processed.add('color')
            self.color = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Answer


class Message(FlowElement):
    subclass = None
    superclass = FlowElement

    def __init__(self, id=None, allowDismiss=None, dismissReference=None, brandingKey=None, autoLock=None, vibrate=None, alertType=None, alertIntervalType=None, content=None, answer=None, attachment=None):
        self.original_tagname_ = None
        super(Message, self).__init__(id,)
        self.allowDismiss = _cast(bool, allowDismiss)
        self.dismissReference = _cast(None, dismissReference)
        self.brandingKey = _cast(None, brandingKey)
        self.autoLock = _cast(bool, autoLock)
        self.vibrate = _cast(bool, vibrate)
        self.alertType = _cast(None, alertType)
        self.alertIntervalType = _cast(None, alertIntervalType)
        self.content = content
        if answer is None:
            self.answer = []
        else:
            self.answer = answer
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Message)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Message.subclass:
            return Message.subclass(*args_, **kwargs_)
        else:
            return Message(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_content(self): return self.content

    def set_content(self, content): self.content = content

    def get_answer(self): return self.answer

    def set_answer(self, answer): self.answer = answer

    def add_answer(self, value): self.answer.append(value)

    def insert_answer_at(self, index, value): self.answer.insert(index, value)

    def replace_answer_at(self, index, value): self.answer[index] = value

    def get_attachment(self): return self.attachment

    def set_attachment(self, attachment): self.attachment = attachment

    def add_attachment(self, value): self.attachment.append(value)

    def insert_attachment_at(self, index, value): self.attachment.insert(index, value)

    def replace_attachment_at(self, index, value): self.attachment[index] = value

    def get_allowDismiss(self): return self.allowDismiss

    def set_allowDismiss(self, allowDismiss): self.allowDismiss = allowDismiss

    def get_dismissReference(self): return self.dismissReference

    def set_dismissReference(self, dismissReference): self.dismissReference = dismissReference

    def get_brandingKey(self): return self.brandingKey

    def set_brandingKey(self, brandingKey): self.brandingKey = brandingKey

    def get_autoLock(self): return self.autoLock

    def set_autoLock(self, autoLock): self.autoLock = autoLock

    def get_vibrate(self): return self.vibrate

    def set_vibrate(self, vibrate): self.vibrate = vibrate

    def get_alertType(self): return self.alertType

    def set_alertType(self, alertType): self.alertType = alertType

    def get_alertIntervalType(self): return self.alertIntervalType

    def set_alertIntervalType(self, alertIntervalType): self.alertIntervalType = alertIntervalType

    def validate_AlertType(self, value):
        # Validate type AlertType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BEEP', 'SILENT', 'RING_5', 'RING_15', 'RING_30', 'RING_60']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AlertType' % {"value" : value.encode("utf-8")})

    def validate_AlertIntervalType(self, value):
        # Validate type AlertIntervalType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NONE', 'INTERVAL_5', 'INTERVAL_15', 'INTERVAL_30', 'INTERVAL_60', 'INTERVAL_300', 'INTERVAL_900', 'INTERVAL_3600']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AlertIntervalType' % {"value" : value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.content is not None or
            self.answer or
            self.attachment or
            super(Message, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='Message', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Message')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Message')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Message', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Message'):
        super(Message, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Message')
        if self.allowDismiss is not None and 'allowDismiss' not in already_processed:
            already_processed.add('allowDismiss')
            outfile.write(' allowDismiss="%s"' % self.gds_format_boolean(self.allowDismiss, input_name='allowDismiss'))
        if self.dismissReference is not None and 'dismissReference' not in already_processed:
            already_processed.add('dismissReference')
            outfile.write(' dismissReference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dismissReference), input_name='dismissReference')),))
        if self.brandingKey is not None and 'brandingKey' not in already_processed:
            already_processed.add('brandingKey')
            outfile.write(' brandingKey=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.brandingKey), input_name='brandingKey')),))
        if self.autoLock is not None and 'autoLock' not in already_processed:
            already_processed.add('autoLock')
            outfile.write(' autoLock="%s"' % self.gds_format_boolean(self.autoLock, input_name='autoLock'))
        if self.vibrate is not None and 'vibrate' not in already_processed:
            already_processed.add('vibrate')
            outfile.write(' vibrate="%s"' % self.gds_format_boolean(self.vibrate, input_name='vibrate'))
        if self.alertType is not None and 'alertType' not in already_processed:
            already_processed.add('alertType')
            outfile.write(' alertType=%s' % (quote_attrib(self.alertType),))
        if self.alertIntervalType is not None and 'alertIntervalType' not in already_processed:
            already_processed.add('alertIntervalType')
            outfile.write(' alertIntervalType=%s' % (quote_attrib(self.alertIntervalType),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Message', fromsubclass_=False, pretty_print=True):
        super(Message, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.content is not None:
            self.content.export(outfile, level, namespaceprefix_, name_='content', pretty_print=pretty_print)
        for answer_ in self.answer:
            answer_.export(outfile, level, namespaceprefix_, name_='answer', pretty_print=pretty_print)
        for attachment_ in self.attachment:
            attachment_.export(outfile, level, namespaceprefix_, name_='attachment', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allowDismiss', node)
        if value is not None and 'allowDismiss' not in already_processed:
            already_processed.add('allowDismiss')
            if value in ('true', '1'):
                self.allowDismiss = True
            elif value in ('false', '0'):
                self.allowDismiss = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dismissReference', node)
        if value is not None and 'dismissReference' not in already_processed:
            already_processed.add('dismissReference')
            self.dismissReference = value
        value = find_attr_value_('brandingKey', node)
        if value is not None and 'brandingKey' not in already_processed:
            already_processed.add('brandingKey')
            self.brandingKey = value
        value = find_attr_value_('autoLock', node)
        if value is not None and 'autoLock' not in already_processed:
            already_processed.add('autoLock')
            if value in ('true', '1'):
                self.autoLock = True
            elif value in ('false', '0'):
                self.autoLock = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vibrate', node)
        if value is not None and 'vibrate' not in already_processed:
            already_processed.add('vibrate')
            if value in ('true', '1'):
                self.vibrate = True
            elif value in ('false', '0'):
                self.vibrate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('alertType', node)
        if value is not None and 'alertType' not in already_processed:
            already_processed.add('alertType')
            self.alertType = value
            self.validate_AlertType(self.alertType)  # validate type AlertType
        value = find_attr_value_('alertIntervalType', node)
        if value is not None and 'alertIntervalType' not in already_processed:
            already_processed.add('alertIntervalType')
            self.alertIntervalType = value
            self.validate_AlertIntervalType(self.alertIntervalType)  # validate type AlertIntervalType
        super(Message, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = contentType.factory()
            obj_.build(child_)
            self.content = obj_
            obj_.original_tagname_ = 'content'
        elif nodeName_ == 'answer':
            obj_ = Answer.factory()
            obj_.build(child_)
            self.answer.append(obj_)
            obj_.original_tagname_ = 'answer'
        elif nodeName_ == 'attachment':
            obj_ = Attachment.factory()
            obj_.build(child_)
            self.attachment.append(obj_)
            obj_.original_tagname_ = 'attachment'
        super(Message, self).buildChildren(child_, node, nodeName_, True)
# end class Message


class ResultsFlush(FlowElement):
    subclass = None
    superclass = FlowElement

    def __init__(self, id=None, reference=None):
        self.original_tagname_ = None
        super(ResultsFlush, self).__init__(id,)
        self.reference = _cast(None, reference)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResultsFlush)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResultsFlush.subclass:
            return ResultsFlush.subclass(*args_, **kwargs_)
        else:
            return ResultsFlush(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_reference(self): return self.reference

    def set_reference(self, reference): self.reference = reference

    def hasContent_(self):
        if (
            super(ResultsFlush, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='ResultsFlush', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResultsFlush')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResultsFlush')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ResultsFlush', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResultsFlush'):
        super(ResultsFlush, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResultsFlush')
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ResultsFlush', fromsubclass_=False, pretty_print=True):
        super(ResultsFlush, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
        super(ResultsFlush, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResultsFlush, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ResultsFlush


class ResultsEmail(FlowElement):
    subclass = None
    superclass = FlowElement

    def __init__(self, id=None, reference=None, emailAdmins=None, email=None):
        self.original_tagname_ = None
        super(ResultsEmail, self).__init__(id,)
        self.reference = _cast(None, reference)
        self.emailAdmins = _cast(bool, emailAdmins)
        if email is None:
            self.email = []
        else:
            self.email = email

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResultsEmail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResultsEmail.subclass:
            return ResultsEmail.subclass(*args_, **kwargs_)
        else:
            return ResultsEmail(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_email(self): return self.email

    def set_email(self, email): self.email = email

    def add_email(self, value): self.email.append(value)

    def insert_email_at(self, index, value): self.email.insert(index, value)

    def replace_email_at(self, index, value): self.email[index] = value

    def get_reference(self): return self.reference

    def set_reference(self, reference): self.reference = reference

    def get_emailAdmins(self): return self.emailAdmins

    def set_emailAdmins(self, emailAdmins): self.emailAdmins = emailAdmins

    def hasContent_(self):
        if (
            self.email or
            super(ResultsEmail, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='ResultsEmail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResultsEmail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResultsEmail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='ResultsEmail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResultsEmail'):
        super(ResultsEmail, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResultsEmail')
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')),))
        if self.emailAdmins is not None and 'emailAdmins' not in already_processed:
            already_processed.add('emailAdmins')
            outfile.write(' emailAdmins="%s"' % self.gds_format_boolean(self.emailAdmins, input_name='emailAdmins'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ResultsEmail', fromsubclass_=False, pretty_print=True):
        super(ResultsEmail, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for email_ in self.email:
            email_.export(outfile, level, namespaceprefix_, name_='email', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
        value = find_attr_value_('emailAdmins', node)
        if value is not None and 'emailAdmins' not in already_processed:
            already_processed.add('emailAdmins')
            if value in ('true', '1'):
                self.emailAdmins = True
            elif value in ('false', '0'):
                self.emailAdmins = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ResultsEmail, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'email':
            class_obj_ = self.get_class_obj_(child_, Value)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.email.append(obj_)
            obj_.original_tagname_ = 'email'
        super(ResultsEmail, self).buildChildren(child_, node, nodeName_, True)
# end class ResultsEmail


class FlowCode(FlowElement):
    subclass = None
    superclass = FlowElement

    def __init__(self, id=None, exceptionReference=None, outlet=None, javascriptCode=None):
        self.original_tagname_ = None
        super(FlowCode, self).__init__(id,)
        self.exceptionReference = _cast(None, exceptionReference)
        if outlet is None:
            self.outlet = []
        else:
            self.outlet = outlet
        self.javascriptCode = javascriptCode

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowCode.subclass:
            return FlowCode.subclass(*args_, **kwargs_)
        else:
            return FlowCode(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_outlet(self): return self.outlet

    def set_outlet(self, outlet): self.outlet = outlet

    def add_outlet(self, value): self.outlet.append(value)

    def insert_outlet_at(self, index, value): self.outlet.insert(index, value)

    def replace_outlet_at(self, index, value): self.outlet[index] = value

    def get_javascriptCode(self): return self.javascriptCode

    def set_javascriptCode(self, javascriptCode): self.javascriptCode = javascriptCode

    def get_exceptionReference(self): return self.exceptionReference

    def set_exceptionReference(self, exceptionReference): self.exceptionReference = exceptionReference

    def hasContent_(self):
        if (
            self.outlet or
            self.javascriptCode is not None or
            super(FlowCode, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='FlowCode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlowCode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowCode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='FlowCode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlowCode'):
        super(FlowCode, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowCode')
        if self.exceptionReference is not None and 'exceptionReference' not in already_processed:
            already_processed.add('exceptionReference')
            outfile.write(' exceptionReference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.exceptionReference), input_name='exceptionReference')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='FlowCode', fromsubclass_=False, pretty_print=True):
        super(FlowCode, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for outlet_ in self.outlet:
            outlet_.export(outfile, level, namespaceprefix_, name_='outlet', pretty_print=pretty_print)
        if self.javascriptCode is not None:
            self.javascriptCode.export(outfile, level, namespaceprefix_, name_='javascriptCode', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exceptionReference', node)
        if value is not None and 'exceptionReference' not in already_processed:
            already_processed.add('exceptionReference')
            self.exceptionReference = value
        super(FlowCode, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'outlet':
            obj_ = Outlet.factory()
            obj_.build(child_)
            self.outlet.append(obj_)
            obj_.original_tagname_ = 'outlet'
        elif nodeName_ == 'javascriptCode':
            obj_ = javascriptCodeType.factory()
            obj_.build(child_)
            self.javascriptCode = obj_
            obj_.original_tagname_ = 'javascriptCode'
        super(FlowCode, self).buildChildren(child_, node, nodeName_, True)
# end class FlowCode


class Widget(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Widget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Widget.subclass:
            return Widget.subclass(*args_, **kwargs_)
        else:
            return Widget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='Widget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Widget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Widget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Widget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Widget'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Widget', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Widget


class BaseSliderWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, min=None, max=None, step=None, precision=None, unit=None, extensiontype_=None):
        self.original_tagname_ = None
        super(BaseSliderWidget, self).__init__(extensiontype_,)
        self.min = _cast(float, min)
        self.max = _cast(float, max)
        self.step = _cast(float, step)
        self.precision = _cast(int, precision)
        self.unit = _cast(None, unit)
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseSliderWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseSliderWidget.subclass:
            return BaseSliderWidget.subclass(*args_, **kwargs_)
        else:
            return BaseSliderWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_min(self): return self.min

    def set_min(self, min): self.min = min

    def get_max(self): return self.max

    def set_max(self, max): self.max = max

    def get_step(self): return self.step

    def set_step(self, step): self.step = step

    def get_precision(self): return self.precision

    def set_precision(self, precision): self.precision = precision

    def get_unit(self): return self.unit

    def set_unit(self, unit): self.unit = unit

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
            super(BaseSliderWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='BaseSliderWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseSliderWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseSliderWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='BaseSliderWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseSliderWidget'):
        super(BaseSliderWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseSliderWidget')
        if self.min is not None and 'min' not in already_processed:
            already_processed.add('min')
            outfile.write(' min="%s"' % self.gds_format_float(self.min, input_name='min'))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_float(self.max, input_name='max'))
        if self.step is not None and 'step' not in already_processed:
            already_processed.add('step')
            outfile.write(' step="%s"' % self.gds_format_float(self.step, input_name='step'))
        if self.precision is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            outfile.write(' precision="%s"' % self.gds_format_integer(self.precision, input_name='precision'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BaseSliderWidget', fromsubclass_=False, pretty_print=True):
        super(BaseSliderWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.add('min')
            try:
                self.min = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (min): %s' % exp)
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            try:
                self.max = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (max): %s' % exp)
        value = find_attr_value_('step', node)
        if value is not None and 'step' not in already_processed:
            already_processed.add('step')
            try:
                self.step = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (step): %s' % exp)
        value = find_attr_value_('precision', node)
        if value is not None and 'precision' not in already_processed:
            already_processed.add('precision')
            try:
                self.precision = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseSliderWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BaseSliderWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseSliderWidget


class SliderWidget(BaseSliderWidget):
    subclass = None
    superclass = BaseSliderWidget

    def __init__(self, min=None, max=None, step=None, precision=None, unit=None, value=None):
        self.original_tagname_ = None
        super(SliderWidget, self).__init__(min, max, step, precision, unit,)
        self.value = _cast(float, value)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SliderWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SliderWidget.subclass:
            return SliderWidget.subclass(*args_, **kwargs_)
        else:
            return SliderWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def hasContent_(self):
        if (
            super(SliderWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SliderWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SliderWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SliderWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SliderWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SliderWidget'):
        super(SliderWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SliderWidget')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_float(self.value, input_name='value'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SliderWidget', fromsubclass_=False, pretty_print=True):
        super(SliderWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        super(SliderWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SliderWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SliderWidget


class RangeSliderWidget(BaseSliderWidget):
    subclass = None
    superclass = BaseSliderWidget

    def __init__(self, min=None, max=None, step=None, precision=None, unit=None, lowValue=None, highValue=None):
        self.original_tagname_ = None
        super(RangeSliderWidget, self).__init__(min, max, step, precision, unit,)
        self.lowValue = _cast(float, lowValue)
        self.highValue = _cast(float, highValue)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RangeSliderWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RangeSliderWidget.subclass:
            return RangeSliderWidget.subclass(*args_, **kwargs_)
        else:
            return RangeSliderWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_lowValue(self): return self.lowValue

    def set_lowValue(self, lowValue): self.lowValue = lowValue

    def get_highValue(self): return self.highValue

    def set_highValue(self, highValue): self.highValue = highValue

    def hasContent_(self):
        if (
            super(RangeSliderWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='RangeSliderWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RangeSliderWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RangeSliderWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RangeSliderWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RangeSliderWidget'):
        super(RangeSliderWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RangeSliderWidget')
        if self.lowValue is not None and 'lowValue' not in already_processed:
            already_processed.add('lowValue')
            outfile.write(' lowValue="%s"' % self.gds_format_float(self.lowValue, input_name='lowValue'))
        if self.highValue is not None and 'highValue' not in already_processed:
            already_processed.add('highValue')
            outfile.write(' highValue="%s"' % self.gds_format_float(self.highValue, input_name='highValue'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RangeSliderWidget', fromsubclass_=False, pretty_print=True):
        super(RangeSliderWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lowValue', node)
        if value is not None and 'lowValue' not in already_processed:
            already_processed.add('lowValue')
            try:
                self.lowValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lowValue): %s' % exp)
        value = find_attr_value_('highValue', node)
        if value is not None and 'highValue' not in already_processed:
            already_processed.add('highValue')
            try:
                self.highValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (highValue): %s' % exp)
        super(RangeSliderWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RangeSliderWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RangeSliderWidget


class PhotoUploadWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, quality=None, gallery=None, camera=None, ratio=None):
        self.original_tagname_ = None
        super(PhotoUploadWidget, self).__init__()
        self.quality = _cast(None, quality)
        self.gallery = _cast(bool, gallery)
        self.camera = _cast(bool, camera)
        self.ratio = _cast(None, ratio)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotoUploadWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotoUploadWidget.subclass:
            return PhotoUploadWidget.subclass(*args_, **kwargs_)
        else:
            return PhotoUploadWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_quality(self): return self.quality

    def set_quality(self, quality): self.quality = quality

    def get_gallery(self): return self.gallery

    def set_gallery(self, gallery): self.gallery = gallery

    def get_camera(self): return self.camera

    def set_camera(self, camera): self.camera = camera

    def get_ratio(self): return self.ratio

    def set_ratio(self, ratio): self.ratio = ratio

    def hasContent_(self):
        if (
            super(PhotoUploadWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='PhotoUploadWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhotoUploadWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhotoUploadWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='PhotoUploadWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhotoUploadWidget'):
        super(PhotoUploadWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhotoUploadWidget')
        if self.quality is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            outfile.write(' quality=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.quality), input_name='quality')),))
        if self.gallery is not None and 'gallery' not in already_processed:
            already_processed.add('gallery')
            outfile.write(' gallery="%s"' % self.gds_format_boolean(self.gallery, input_name='gallery'))
        if self.camera is not None and 'camera' not in already_processed:
            already_processed.add('camera')
            outfile.write(' camera="%s"' % self.gds_format_boolean(self.camera, input_name='camera'))
        if self.ratio is not None and 'ratio' not in already_processed:
            already_processed.add('ratio')
            outfile.write(' ratio=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ratio), input_name='ratio')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='PhotoUploadWidget', fromsubclass_=False, pretty_print=True):
        super(PhotoUploadWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quality', node)
        if value is not None and 'quality' not in already_processed:
            already_processed.add('quality')
            self.quality = value
        value = find_attr_value_('gallery', node)
        if value is not None and 'gallery' not in already_processed:
            already_processed.add('gallery')
            if value in ('true', '1'):
                self.gallery = True
            elif value in ('false', '0'):
                self.gallery = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('camera', node)
        if value is not None and 'camera' not in already_processed:
            already_processed.add('camera')
            if value in ('true', '1'):
                self.camera = True
            elif value in ('false', '0'):
                self.camera = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ratio', node)
        if value is not None and 'ratio' not in already_processed:
            already_processed.add('ratio')
            self.ratio = value
        super(PhotoUploadWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PhotoUploadWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PhotoUploadWidget


class GPSLocationWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, gps=None):
        self.original_tagname_ = None
        super(GPSLocationWidget, self).__init__()
        self.gps = _cast(bool, gps)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GPSLocationWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GPSLocationWidget.subclass:
            return GPSLocationWidget.subclass(*args_, **kwargs_)
        else:
            return GPSLocationWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_gps(self): return self.gps

    def set_gps(self, gps): self.gps = gps

    def hasContent_(self):
        if (
            super(GPSLocationWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='GPSLocationWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GPSLocationWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GPSLocationWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='GPSLocationWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GPSLocationWidget'):
        super(GPSLocationWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GPSLocationWidget')
        if self.gps is not None and 'gps' not in already_processed:
            already_processed.add('gps')
            outfile.write(' gps="%s"' % self.gds_format_boolean(self.gps, input_name='gps'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='GPSLocationWidget', fromsubclass_=False, pretty_print=True):
        super(GPSLocationWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gps', node)
        if value is not None and 'gps' not in already_processed:
            already_processed.add('gps')
            if value in ('true', '1'):
                self.gps = True
            elif value in ('false', '0'):
                self.gps = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(GPSLocationWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GPSLocationWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GPSLocationWidget


class TextWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, maxChars=None, placeholder=None, value=None, keyboardType=None, extensiontype_=None):
        self.original_tagname_ = None
        super(TextWidget, self).__init__(extensiontype_,)
        self.maxChars = _cast(int, maxChars)
        self.placeholder = _cast(None, placeholder)
        self.value = _cast(None, value)
        self.keyboardType = _cast(None, keyboardType)
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextWidget.subclass:
            return TextWidget.subclass(*args_, **kwargs_)
        else:
            return TextWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_maxChars(self): return self.maxChars

    def set_maxChars(self, maxChars): self.maxChars = maxChars

    def get_placeholder(self): return self.placeholder

    def set_placeholder(self, placeholder): self.placeholder = placeholder

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def get_keyboardType(self): return self.keyboardType

    def set_keyboardType(self, keyboardType): self.keyboardType = keyboardType

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def validate_KeyboardType(self, value):
        # Validate type KeyboardType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['DEFAULT', 'AUTO_CAPITALIZED', 'EMAIL', 'URL', 'PHONE', 'NUMBER', 'DECIMAL', 'PASSWORD', 'NUMBER_PASSWORD']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on KeyboardType' % {"value" : value.encode("utf-8")})

    def hasContent_(self):
        if (
            super(TextWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='TextWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TextWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextWidget'):
        super(TextWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextWidget')
        if self.maxChars is not None and 'maxChars' not in already_processed:
            already_processed.add('maxChars')
            outfile.write(' maxChars="%s"' % self.gds_format_integer(self.maxChars, input_name='maxChars'))
        if self.placeholder is not None and 'placeholder' not in already_processed:
            already_processed.add('placeholder')
            outfile.write(' placeholder=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.placeholder), input_name='placeholder')),))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')),))
        if self.keyboardType is not None and 'keyboardType' not in already_processed:
            already_processed.add('keyboardType')
            outfile.write(' keyboardType=%s' % (quote_attrib(self.keyboardType),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TextWidget', fromsubclass_=False, pretty_print=True):
        super(TextWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxChars', node)
        if value is not None and 'maxChars' not in already_processed:
            already_processed.add('maxChars')
            try:
                self.maxChars = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('placeholder', node)
        if value is not None and 'placeholder' not in already_processed:
            already_processed.add('placeholder')
            self.placeholder = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('keyboardType', node)
        if value is not None and 'keyboardType' not in already_processed:
            already_processed.add('keyboardType')
            self.keyboardType = value
            self.validate_KeyboardType(self.keyboardType)  # validate type KeyboardType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TextWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextWidget


class TextLineWidget(TextWidget):
    subclass = None
    superclass = TextWidget

    def __init__(self, maxChars=None, placeholder=None, value=None, keyboardType=None):
        self.original_tagname_ = None
        super(TextLineWidget, self).__init__(maxChars, placeholder, value, keyboardType,)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextLineWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextLineWidget.subclass:
            return TextLineWidget.subclass(*args_, **kwargs_)
        else:
            return TextLineWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def hasContent_(self):
        if (
            super(TextLineWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='TextLineWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextLineWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextLineWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TextLineWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextLineWidget'):
        super(TextLineWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextLineWidget')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TextLineWidget', fromsubclass_=False, pretty_print=True):
        super(TextLineWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(TextLineWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextLineWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextLineWidget


class TextBlockWidget(TextWidget):
    subclass = None
    superclass = TextWidget

    def __init__(self, maxChars=None, placeholder=None, value=None, keyboardType=None):
        self.original_tagname_ = None
        super(TextBlockWidget, self).__init__(maxChars, placeholder, value, keyboardType,)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextBlockWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextBlockWidget.subclass:
            return TextBlockWidget.subclass(*args_, **kwargs_)
        else:
            return TextBlockWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def hasContent_(self):
        if (
            super(TextBlockWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='TextBlockWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextBlockWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBlockWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TextBlockWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextBlockWidget'):
        super(TextBlockWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBlockWidget')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TextBlockWidget', fromsubclass_=False, pretty_print=True):
        super(TextBlockWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(TextBlockWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextBlockWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextBlockWidget


class Value(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, value=None, extensiontype_=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Value)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Value.subclass:
            return Value.subclass(*args_, **kwargs_)
        else:
            return Value(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='Value', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Value')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Value')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Value', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Value'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Value', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Value


class FloatValue(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, value=None):
        self.original_tagname_ = None
        self.value = _cast(float, value)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FloatValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FloatValue.subclass:
            return FloatValue.subclass(*args_, **kwargs_)
        else:
            return FloatValue(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='FloatValue', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FloatValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FloatValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='FloatValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FloatValue'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_float(self.value, input_name='value'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='FloatValue', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FloatValue


class AdvancedOrderCategory(FlowElement):
    subclass = None
    superclass = FlowElement

    def __init__(self, id=None, name=None, item=None):
        self.original_tagname_ = None
        super(AdvancedOrderCategory, self).__init__(id,)
        self.name = name
        if item is None:
            self.item = []
        else:
            self.item = item

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdvancedOrderCategory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdvancedOrderCategory.subclass:
            return AdvancedOrderCategory.subclass(*args_, **kwargs_)
        else:
            return AdvancedOrderCategory(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_name(self): return self.name

    def set_name(self, name): self.name = name

    def get_item(self): return self.item

    def set_item(self, item): self.item = item

    def add_item(self, value): self.item.append(value)

    def insert_item_at(self, index, value): self.item.insert(index, value)

    def replace_item_at(self, index, value): self.item[index] = value

    def hasContent_(self):
        if (
            self.name is not None or
            self.item or
            super(AdvancedOrderCategory, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='AdvancedOrderCategory', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdvancedOrderCategory')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdvancedOrderCategory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AdvancedOrderCategory', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdvancedOrderCategory'):
        super(AdvancedOrderCategory, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdvancedOrderCategory')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AdvancedOrderCategory', fromsubclass_=False, pretty_print=True):
        super(AdvancedOrderCategory, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<name>%s</name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        for item_ in self.item:
            item_.export(outfile, level, namespaceprefix_, name_='item', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(AdvancedOrderCategory, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'item':
            obj_ = AdvancedOrderItem.factory()
            obj_.build(child_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
        super(AdvancedOrderCategory, self).buildChildren(child_, node, nodeName_, True)
# end class AdvancedOrderCategory


class AdvancedOrderItem(FlowElement):
    subclass = None
    superclass = FlowElement

    def __init__(self, id=None, value=None, unit=None, unitPrice=None, hasPrice=True, step=None, stepUnit=None, stepUnitConversion=None, imageUrl=None, name=None, description=None):
        self.original_tagname_ = None
        super(AdvancedOrderItem, self).__init__(id,)
        self.value = _cast(int, value)
        self.unit = _cast(None, unit)
        self.unitPrice = _cast(int, unitPrice)
        self.hasPrice = _cast(bool, hasPrice)
        self.step = _cast(int, step)
        self.stepUnit = _cast(None, stepUnit)
        self.stepUnitConversion = _cast(int, stepUnitConversion)
        self.imageUrl = _cast(None, imageUrl)
        self.name = name
        self.description = description

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdvancedOrderItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdvancedOrderItem.subclass:
            return AdvancedOrderItem.subclass(*args_, **kwargs_)
        else:
            return AdvancedOrderItem(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_name(self): return self.name

    def set_name(self, name): self.name = name

    def get_description(self): return self.description

    def set_description(self, description): self.description = description

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def get_unit(self): return self.unit

    def set_unit(self, unit): self.unit = unit

    def get_unitPrice(self): return self.unitPrice

    def set_unitPrice(self, unitPrice): self.unitPrice = unitPrice

    def get_hasPrice(self): return self.hasPrice

    def set_hasPrice(self, hasPrice): self.hasPrice = hasPrice

    def get_step(self): return self.step

    def set_step(self, step): self.step = step

    def get_stepUnit(self): return self.stepUnit

    def set_stepUnit(self, stepUnit): self.stepUnit = stepUnit

    def get_stepUnitConversion(self): return self.stepUnitConversion

    def set_stepUnitConversion(self, stepUnitConversion): self.stepUnitConversion = stepUnitConversion

    def get_imageUrl(self): return self.imageUrl

    def set_imageUrl(self, imageUrl): self.imageUrl = imageUrl

    def hasContent_(self):
        if (
            self.name is not None or
            self.description is not None or
            super(AdvancedOrderItem, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='AdvancedOrderItem', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdvancedOrderItem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdvancedOrderItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AdvancedOrderItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdvancedOrderItem'):
        super(AdvancedOrderItem, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdvancedOrderItem')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')),))
        if self.unitPrice is not None and 'unitPrice' not in already_processed:
            already_processed.add('unitPrice')
            outfile.write(' unitPrice="%s"' % self.gds_format_integer(self.unitPrice, input_name='unitPrice'))
        if not self.hasPrice and 'hasPrice' not in already_processed:
            already_processed.add('hasPrice')
            outfile.write(' hasPrice="%s"' % self.gds_format_boolean(self.hasPrice, input_name='hasPrice'))
        if self.step is not None and 'step' not in already_processed:
            already_processed.add('step')
            outfile.write(' step="%s"' % self.gds_format_integer(self.step, input_name='step'))
        if self.stepUnit is not None and 'stepUnit' not in already_processed:
            already_processed.add('stepUnit')
            outfile.write(' stepUnit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.stepUnit), input_name='stepUnit')),))
        if self.stepUnitConversion is not None and 'stepUnitConversion' not in already_processed:
            already_processed.add('stepUnitConversion')
            outfile.write(' stepUnitConversion="%s"' % self.gds_format_integer(self.stepUnitConversion, input_name='stepUnitConversion'))
        if self.imageUrl is not None and 'imageUrl' not in already_processed:
            already_processed.add('imageUrl')
            outfile.write(' imageUrl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageUrl), input_name='imageUrl')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AdvancedOrderItem', fromsubclass_=False, pretty_print=True):
        super(AdvancedOrderItem, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<name>%s</name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<description>%s</description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('unitPrice', node)
        if value is not None and 'unitPrice' not in already_processed:
            already_processed.add('unitPrice')
            try:
                self.unitPrice = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('hasPrice', node)
        if value is not None and 'hasPrice' not in already_processed:
            already_processed.add('hasPrice')
            if value in ('true', '1'):
                self.hasPrice = True
            elif value in ('false', '0'):
                self.hasPrice = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('step', node)
        if value is not None and 'step' not in already_processed:
            already_processed.add('step')
            try:
                self.step = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('stepUnit', node)
        if value is not None and 'stepUnit' not in already_processed:
            already_processed.add('stepUnit')
            self.stepUnit = value
        value = find_attr_value_('stepUnitConversion', node)
        if value is not None and 'stepUnitConversion' not in already_processed:
            already_processed.add('stepUnitConversion')
            try:
                self.stepUnitConversion = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('imageUrl', node)
        if value is not None and 'imageUrl' not in already_processed:
            already_processed.add('imageUrl')
            self.imageUrl = value
        super(AdvancedOrderItem, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        super(AdvancedOrderItem, self).buildChildren(child_, node, nodeName_, True)
# end class AdvancedOrderItem


class BasePaymentMethod(FlowElement):
    subclass = None
    superclass = FlowElement

    def __init__(self, id=None, currency=None, amount=None, precision=None, extensiontype_=None):
        self.original_tagname_ = None
        super(BasePaymentMethod, self).__init__(id, extensiontype_,)
        self.currency = currency
        self.amount = amount
        self.precision = precision
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BasePaymentMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BasePaymentMethod.subclass:
            return BasePaymentMethod.subclass(*args_, **kwargs_)
        else:
            return BasePaymentMethod(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_currency(self): return self.currency

    def set_currency(self, currency): self.currency = currency

    def get_amount(self): return self.amount

    def set_amount(self, amount): self.amount = amount

    def get_precision(self): return self.precision

    def set_precision(self, precision): self.precision = precision

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
            self.currency is not None or
            self.amount is not None or
            self.precision is not None or
            super(BasePaymentMethod, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='BasePaymentMethod', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BasePaymentMethod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasePaymentMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='BasePaymentMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BasePaymentMethod'):
        super(BasePaymentMethod, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BasePaymentMethod')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BasePaymentMethod', fromsubclass_=False, pretty_print=True):
        super(BasePaymentMethod, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<currency>%s</currency>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.currency), input_name='currency')), eol_))
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<amount>%s</amount>%s' % (self.gds_format_integer(self.amount, input_name='amount'), eol_))
        if self.precision is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<precision>%s</precision>%s' % (self.gds_format_integer(self.precision, input_name='precision'), eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BasePaymentMethod, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            currency_ = child_.text
            currency_ = self.gds_validate_string(currency_, node, 'currency')
            self.currency = currency_
        elif nodeName_ == 'amount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'amount')
            self.amount = ival_
        elif nodeName_ == 'precision' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'precision')
            self.precision = ival_
        super(BasePaymentMethod, self).buildChildren(child_, node, nodeName_, True)
# end class BasePaymentMethod


class PaymentMethod(BasePaymentMethod):
    subclass = None
    superclass = BasePaymentMethod

    def __init__(self, id=None, currency=None, amount=None, precision=None, provider_id=None, calculateAmount=False, target=None):
        self.original_tagname_ = None
        super(PaymentMethod, self).__init__(id, currency, amount, precision,)
        self.provider_id = provider_id
        self.calculateAmount = calculateAmount
        self.target = target

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PaymentMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PaymentMethod.subclass:
            return PaymentMethod.subclass(*args_, **kwargs_)
        else:
            return PaymentMethod(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_provider_id(self): return self.provider_id

    def set_provider_id(self, provider_id): self.provider_id = provider_id

    def get_calculateAmount(self): return self.calculateAmount

    def set_calculateAmount(self, calculateAmount): self.calculateAmount = calculateAmount

    def get_target(self): return self.target

    def set_target(self, target): self.target = target

    def hasContent_(self):
        if (
            self.provider_id is not None or
            self.calculateAmount or
            self.target is not None or
            super(PaymentMethod, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='PaymentMethod', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PaymentMethod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaymentMethod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='PaymentMethod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PaymentMethod'):
        super(PaymentMethod, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PaymentMethod')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='PaymentMethod', fromsubclass_=False, pretty_print=True):
        super(PaymentMethod, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.provider_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<provider_id>%s</provider_id>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.provider_id), input_name='provider_id')), eol_))
        if self.calculateAmount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<calculateAmount>%s</calculateAmount>%s' % (self.gds_format_boolean(self.calculateAmount, input_name='calculateAmount'), eol_))
        if self.target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<target>%s</target>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.target), input_name='target')), eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(PaymentMethod, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'provider_id':
            provider_id_ = child_.text
            provider_id_ = self.gds_validate_string(provider_id_, node, 'provider_id')
            self.provider_id = provider_id_
        elif nodeName_ == 'calculateAmount':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'calculateAmount')
            self.calculateAmount = ival_
        elif nodeName_ == 'target':
            target_ = child_.text
            target_ = self.gds_validate_string(target_, node, 'target')
            self.target = target_
        super(PaymentMethod, self).buildChildren(child_, node, nodeName_, True)
# end class PaymentMethod


class TextAutocompleteWidget(TextWidget):
    subclass = None
    superclass = TextWidget

    def __init__(self, maxChars=None, placeholder=None, value=None, keyboardType=None, suggestion=None):
        self.original_tagname_ = None
        super(TextAutocompleteWidget, self).__init__(maxChars, placeholder, value, keyboardType,)
        if suggestion is None:
            self.suggestion = []
        else:
            self.suggestion = suggestion

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextAutocompleteWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextAutocompleteWidget.subclass:
            return TextAutocompleteWidget.subclass(*args_, **kwargs_)
        else:
            return TextAutocompleteWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_suggestion(self): return self.suggestion

    def set_suggestion(self, suggestion): self.suggestion = suggestion

    def add_suggestion(self, value): self.suggestion.append(value)

    def insert_suggestion_at(self, index, value): self.suggestion.insert(index, value)

    def replace_suggestion_at(self, index, value): self.suggestion[index] = value

    def hasContent_(self):
        if (
            self.suggestion or
            super(TextAutocompleteWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='TextAutocompleteWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextAutocompleteWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextAutocompleteWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TextAutocompleteWidget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextAutocompleteWidget'):
        super(TextAutocompleteWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextAutocompleteWidget')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TextAutocompleteWidget', fromsubclass_=False, pretty_print=True):
        super(TextAutocompleteWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for suggestion_ in self.suggestion:
            suggestion_.export(outfile, level, namespaceprefix_, name_='suggestion', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(TextAutocompleteWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'suggestion':
            class_obj_ = self.get_class_obj_(child_, Value)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.suggestion.append(obj_)
            obj_.original_tagname_ = 'suggestion'
        super(TextAutocompleteWidget, self).buildChildren(child_, node, nodeName_, True)
# end class TextAutocompleteWidget


class Choice(Value):
    subclass = None
    superclass = Value

    def __init__(self, value=None, label=None):
        self.original_tagname_ = None
        super(Choice, self).__init__(value,)
        self.label = _cast(None, label)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Choice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Choice.subclass:
            return Choice.subclass(*args_, **kwargs_)
        else:
            return Choice(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_label(self): return self.label

    def set_label(self, label): self.label = label

    def hasContent_(self):
        if (
            super(Choice, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='Choice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Choice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Choice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Choice', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Choice'):
        super(Choice, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Choice')
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Choice', fromsubclass_=False, pretty_print=True):
        super(Choice, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        super(Choice, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Choice, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Choice


class SelectWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, choice=None, extensiontype_=None):
        self.original_tagname_ = None
        super(SelectWidget, self).__init__(extensiontype_,)
        if choice is None:
            self.choice = []
        else:
            self.choice = choice
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectWidget.subclass:
            return SelectWidget.subclass(*args_, **kwargs_)
        else:
            return SelectWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_choice(self): return self.choice

    def set_choice(self, choice): self.choice = choice

    def add_choice(self, value): self.choice.append(value)

    def insert_choice_at(self, index, value): self.choice.insert(index, value)

    def replace_choice_at(self, index, value): self.choice[index] = value

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
            self.choice or
            super(SelectWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SelectWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SelectWidget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelectWidget'):
        super(SelectWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectWidget')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SelectWidget', fromsubclass_=False, pretty_print=True):
        super(SelectWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for choice_ in self.choice:
            choice_.export(outfile, level, namespaceprefix_, name_='choice', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(SelectWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'choice':
            obj_ = Choice.factory()
            obj_.build(child_)
            self.choice.append(obj_)
            obj_.original_tagname_ = 'choice'
        super(SelectWidget, self).buildChildren(child_, node, nodeName_, True)
# end class SelectWidget


class SelectSingleWidget(SelectWidget):
    subclass = None
    superclass = SelectWidget

    def __init__(self, choice=None, value=None):
        self.original_tagname_ = None
        super(SelectSingleWidget, self).__init__(choice,)
        self.value = _cast(None, value)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectSingleWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectSingleWidget.subclass:
            return SelectSingleWidget.subclass(*args_, **kwargs_)
        else:
            return SelectSingleWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def hasContent_(self):
        if (
            super(SelectSingleWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SelectSingleWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectSingleWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectSingleWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SelectSingleWidget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelectSingleWidget'):
        super(SelectSingleWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectSingleWidget')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SelectSingleWidget', fromsubclass_=False, pretty_print=True):
        super(SelectSingleWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(SelectSingleWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelectSingleWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelectSingleWidget


class SelectMultiWidget(SelectWidget):
    subclass = None
    superclass = SelectWidget

    def __init__(self, choice=None, value=None):
        self.original_tagname_ = None
        super(SelectMultiWidget, self).__init__(choice,)
        if value is None:
            self.value = []
        else:
            self.value = value

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectMultiWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectMultiWidget.subclass:
            return SelectMultiWidget.subclass(*args_, **kwargs_)
        else:
            return SelectMultiWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def add_value(self, value): self.value.append(value)

    def insert_value_at(self, index, value): self.value.insert(index, value)

    def replace_value_at(self, index, value): self.value[index] = value

    def hasContent_(self):
        if (
            self.value or
            super(SelectMultiWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SelectMultiWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectMultiWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectMultiWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SelectMultiWidget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelectMultiWidget'):
        super(SelectMultiWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectMultiWidget')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SelectMultiWidget', fromsubclass_=False, pretty_print=True):
        super(SelectMultiWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            value_.export(outfile, level, namespaceprefix_, name_='value', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(SelectMultiWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, Value)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
        super(SelectMultiWidget, self).buildChildren(child_, node, nodeName_, True)
# end class SelectMultiWidget


class SelectDateWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, minDate=None, maxDate=None, date=None, minuteInterval=None, mode=None, unit=None):
        self.original_tagname_ = None
        super(SelectDateWidget, self).__init__()
        self.minDate = _cast(int, minDate)
        self.maxDate = _cast(int, maxDate)
        self.date = _cast(int, date)
        self.minuteInterval = _cast(int, minuteInterval)
        self.mode = _cast(None, mode)
        self.unit = _cast(None, unit)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectDateWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectDateWidget.subclass:
            return SelectDateWidget.subclass(*args_, **kwargs_)
        else:
            return SelectDateWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_minDate(self): return self.minDate

    def set_minDate(self, minDate): self.minDate = minDate

    def get_maxDate(self): return self.maxDate

    def set_maxDate(self, maxDate): self.maxDate = maxDate

    def get_date(self): return self.date

    def set_date(self, date): self.date = date

    def get_minuteInterval(self): return self.minuteInterval

    def set_minuteInterval(self, minuteInterval): self.minuteInterval = minuteInterval

    def get_mode(self): return self.mode

    def set_mode(self, mode): self.mode = mode

    def get_unit(self): return self.unit

    def set_unit(self, unit): self.unit = unit

    def hasContent_(self):
        if (
            super(SelectDateWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SelectDateWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectDateWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectDateWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SelectDateWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelectDateWidget'):
        super(SelectDateWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectDateWidget')
        if self.minDate is not None and 'minDate' not in already_processed:
            already_processed.add('minDate')
            outfile.write(' minDate="%s"' % self.gds_format_integer(self.minDate, input_name='minDate'))
        if self.maxDate is not None and 'maxDate' not in already_processed:
            already_processed.add('maxDate')
            outfile.write(' maxDate="%s"' % self.gds_format_integer(self.maxDate, input_name='maxDate'))
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date="%s"' % self.gds_format_integer(self.date, input_name='date'))
        if self.minuteInterval is not None and 'minuteInterval' not in already_processed:
            already_processed.add('minuteInterval')
            outfile.write(' minuteInterval="%s"' % self.gds_format_integer(self.minuteInterval, input_name='minuteInterval'))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.mode), input_name='mode')),))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SelectDateWidget', fromsubclass_=False, pretty_print=True):
        super(SelectDateWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minDate', node)
        if value is not None and 'minDate' not in already_processed:
            already_processed.add('minDate')
            try:
                self.minDate = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maxDate', node)
        if value is not None and 'maxDate' not in already_processed:
            already_processed.add('maxDate')
            try:
                self.maxDate = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            try:
                self.date = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('minuteInterval', node)
        if value is not None and 'minuteInterval' not in already_processed:
            already_processed.add('minuteInterval')
            try:
                self.minuteInterval = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        super(SelectDateWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelectDateWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelectDateWidget


class SelectFriendWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, selectionRequired=None, multiSelect=None):
        self.original_tagname_ = None
        super(SelectFriendWidget, self).__init__()
        self.selectionRequired = _cast(bool, selectionRequired)
        self.multiSelect = _cast(bool, multiSelect)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectFriendWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectFriendWidget.subclass:
            return SelectFriendWidget.subclass(*args_, **kwargs_)
        else:
            return SelectFriendWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_selectionRequired(self): return self.selectionRequired

    def set_selectionRequired(self, selectionRequired): self.selectionRequired = selectionRequired

    def get_multiSelect(self): return self.multiSelect

    def set_multiSelect(self, multiSelect): self.multiSelect = multiSelect

    def hasContent_(self):
        if (
            super(SelectFriendWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SelectFriendWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectFriendWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectFriendWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SelectFriendWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelectFriendWidget'):
        super(SelectFriendWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectFriendWidget')
        if self.selectionRequired is not None and 'selectionRequired' not in already_processed:
            already_processed.add('selectionRequired')
            outfile.write(' selectionRequired="%s"' % self.gds_format_boolean(self.selectionRequired, input_name='selectionRequired'))
        if self.multiSelect is not None and 'multiSelect' not in already_processed:
            already_processed.add('multiSelect')
            outfile.write(' multiSelect="%s"' % self.gds_format_boolean(self.multiSelect, input_name='multiSelect'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SelectFriendWidget', fromsubclass_=False, pretty_print=True):
        super(SelectFriendWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('selectionRequired', node)
        if value is not None and 'selectionRequired' not in already_processed:
            already_processed.add('selectionRequired')
            if value in ('true', '1'):
                self.selectionRequired = True
            elif value in ('false', '0'):
                self.selectionRequired = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('multiSelect', node)
        if value is not None and 'multiSelect' not in already_processed:
            already_processed.add('multiSelect')
            if value in ('true', '1'):
                self.multiSelect = True
            elif value in ('false', '0'):
                self.multiSelect = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(SelectFriendWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelectFriendWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelectFriendWidget


class MyDigiPassWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, scope=None):
        self.original_tagname_ = None
        super(MyDigiPassWidget, self).__init__()
        self.scope = _cast(None, scope)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MyDigiPassWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MyDigiPassWidget.subclass:
            return MyDigiPassWidget.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_scope(self): return self.scope

    def set_scope(self, scope): self.scope = scope

    def hasContent_(self):
        if (
            super(MyDigiPassWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MyDigiPassWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MyDigiPassWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MyDigiPassWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MyDigiPassWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MyDigiPassWidget'):
        super(MyDigiPassWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MyDigiPassWidget')
        if self.scope is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MyDigiPassWidget', fromsubclass_=False, pretty_print=True):
        super(MyDigiPassWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
        super(MyDigiPassWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MyDigiPassWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MyDigiPassWidget


class AdvancedOrderWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, currency=None, leapTime=None, category=None):
        self.original_tagname_ = None
        super(AdvancedOrderWidget, self).__init__()
        self.currency = _cast(None, currency)
        self.leapTime = _cast(int, leapTime)
        if category is None:
            self.category = []
        else:
            self.category = category

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdvancedOrderWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdvancedOrderWidget.subclass:
            return AdvancedOrderWidget.subclass(*args_, **kwargs_)
        else:
            return AdvancedOrderWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_category(self): return self.category

    def set_category(self, category): self.category = category

    def add_category(self, value): self.category.append(value)

    def insert_category_at(self, index, value): self.category.insert(index, value)

    def replace_category_at(self, index, value): self.category[index] = value

    def get_currency(self): return self.currency

    def set_currency(self, currency): self.currency = currency

    def get_leapTime(self): return self.leapTime

    def set_leapTime(self, leapTime): self.leapTime = leapTime

    def hasContent_(self):
        if (
            self.category or
            super(AdvancedOrderWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='AdvancedOrderWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdvancedOrderWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdvancedOrderWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AdvancedOrderWidget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdvancedOrderWidget'):
        super(AdvancedOrderWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdvancedOrderWidget')
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.currency), input_name='currency')),))
        if self.leapTime is not None and 'leapTime' not in already_processed:
            already_processed.add('leapTime')
            outfile.write(' leapTime="%s"' % self.gds_format_integer(self.leapTime, input_name='leapTime'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AdvancedOrderWidget', fromsubclass_=False, pretty_print=True):
        super(AdvancedOrderWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for category_ in self.category:
            category_.export(outfile, level, namespaceprefix_, name_='category', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
        value = find_attr_value_('leapTime', node)
        if value is not None and 'leapTime' not in already_processed:
            already_processed.add('leapTime')
            try:
                self.leapTime = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(AdvancedOrderWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'category':
            obj_ = AdvancedOrderCategory.factory()
            obj_.build(child_)
            self.category.append(obj_)
            obj_.original_tagname_ = 'category'
        super(AdvancedOrderWidget, self).buildChildren(child_, node, nodeName_, True)
# end class AdvancedOrderWidget


class SignWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, caption=None, algorithm=None, keyName=None, index=None, payload=None):
        self.original_tagname_ = None
        super(SignWidget, self).__init__()
        self.caption = _cast(None, caption)
        self.algorithm = _cast(None, algorithm)
        self.keyName = _cast(None, keyName)
        self.index = _cast(None, index)
        self.payload = payload

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignWidget.subclass:
            return SignWidget.subclass(*args_, **kwargs_)
        else:
            return SignWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_payload(self): return self.payload

    def set_payload(self, payload): self.payload = payload

    def get_caption(self): return self.caption

    def set_caption(self, caption): self.caption = caption

    def get_algorithm(self): return self.algorithm

    def set_algorithm(self, algorithm): self.algorithm = algorithm

    def get_keyName(self): return self.keyName

    def set_keyName(self, keyName): self.keyName = keyName

    def get_index(self): return self.index

    def set_index(self, index): self.index = index

    def hasContent_(self):
        if (
            self.payload is not None or
            super(SignWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SignWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SignWidget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SignWidget'):
        super(SignWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignWidget')
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caption), input_name='caption')),))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.add('algorithm')
            outfile.write(' algorithm=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.algorithm), input_name='algorithm')),))
        if self.keyName is not None and 'keyName' not in already_processed:
            already_processed.add('keyName')
            outfile.write(' keyName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keyName), input_name='keyName')),))
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.index), input_name='index')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SignWidget', fromsubclass_=False, pretty_print=True):
        super(SignWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.payload is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<payload>%s</payload>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.payload), input_name='payload')), eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.add('algorithm')
            self.algorithm = value
        value = find_attr_value_('keyName', node)
        if value is not None and 'keyName' not in already_processed:
            already_processed.add('keyName')
            self.keyName = value
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            self.index = value
        super(SignWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payload':
            payload_ = child_.text
            payload_ = self.gds_validate_string(payload_, node, 'payload')
            self.payload = payload_
        super(SignWidget, self).buildChildren(child_, node, nodeName_, True)
# end class SignWidget


class OauthWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, url=None, caption=None, successMessage=None):
        self.original_tagname_ = None
        super(OauthWidget, self).__init__()
        self.url = _cast(None, url)
        self.caption = _cast(None, caption)
        self.successMessage = _cast(None, successMessage)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OauthWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OauthWidget.subclass:
            return OauthWidget.subclass(*args_, **kwargs_)
        else:
            return OauthWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_url(self): return self.url

    def set_url(self, url): self.url = url

    def get_caption(self): return self.caption

    def set_caption(self, caption): self.caption = caption

    def get_successMessage(self): return self.successMessage

    def set_successMessage(self, successMessage): self.successMessage = successMessage

    def hasContent_(self):
        if (
            super(OauthWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='OauthWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OauthWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OauthWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='OauthWidget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OauthWidget'):
        super(OauthWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OauthWidget')
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.url), input_name='url')),))
        if self.caption is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            outfile.write(' caption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.caption), input_name='caption')),))
        if self.successMessage is not None and 'successMessage' not in already_processed:
            already_processed.add('successMessage')
            outfile.write(' successMessage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.successMessage), input_name='successMessage')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='OauthWidget', fromsubclass_=False, pretty_print=True):
        super(OauthWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
        value = find_attr_value_('caption', node)
        if value is not None and 'caption' not in already_processed:
            already_processed.add('caption')
            self.caption = value
        value = find_attr_value_('successMessage', node)
        if value is not None and 'successMessage' not in already_processed:
            already_processed.add('successMessage')
            self.successMessage = value
        super(OauthWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(OauthWidget, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OauthWidget


class PayWidget(Widget):
    subclass = None
    superclass = Widget

    def __init__(self, memo=None, target=None, autoSubmit=True, testMode=False, embeddedAppId=None, method=None, baseMethod=None):
        self.original_tagname_ = None
        super(PayWidget, self).__init__()
        self.memo = _cast(None, memo)
        self.target = _cast(None, target)
        self.autoSubmit = _cast(bool, autoSubmit)
        self.testMode = _cast(bool, testMode)
        self.embeddedAppId = _cast(None, embeddedAppId)
        if method is None:
            self.method = []
        else:
            self.method = method
        self.baseMethod = baseMethod

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PayWidget)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PayWidget.subclass:
            return PayWidget.subclass(*args_, **kwargs_)
        else:
            return PayWidget(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_method(self): return self.method

    def set_method(self, method): self.method = method

    def add_method(self, value): self.method.append(value)

    def insert_method_at(self, index, value): self.method.insert(index, value)

    def replace_method_at(self, index, value): self.method[index] = value

    def get_baseMethod(self): return self.baseMethod

    def set_baseMethod(self, baseMethod): self.baseMethod = baseMethod

    def get_memo(self): return self.memo

    def set_memo(self, memo): self.memo = memo

    def get_target(self): return self.target

    def set_target(self, target): self.target = target

    def get_autoSubmit(self): return self.autoSubmit

    def set_autoSubmit(self, autoSubmit): self.autoSubmit = autoSubmit

    def get_testMode(self): return self.testMode

    def set_testMode(self, testMode): self.testMode = testMode

    def get_embeddedAppId(self): return self.embeddedAppId

    def set_embeddedAppId(self, embeddedAppId): self.embeddedAppId = embeddedAppId

    def hasContent_(self):
        if (
            self.method or
            self.baseMethod is not None or
            super(PayWidget, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='PayWidget', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PayWidget')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PayWidget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='PayWidget', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PayWidget'):
        super(PayWidget, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PayWidget')
        if self.memo is not None and 'memo' not in already_processed:
            already_processed.add('memo')
            outfile.write(' memo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.memo), input_name='memo')),))
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')),))
        if not self.autoSubmit and 'autoSubmit' not in already_processed:
            already_processed.add('autoSubmit')
            outfile.write(' autoSubmit="%s"' % self.gds_format_boolean(self.autoSubmit, input_name='autoSubmit'))
        if self.testMode and 'testMode' not in already_processed:
            already_processed.add('testMode')
            outfile.write(' testMode="%s"' % self.gds_format_boolean(self.testMode, input_name='testMode'))
        if self.embeddedAppId is not None and 'embeddedAppId' not in already_processed:
            already_processed.add('embeddedAppId')
            outfile.write(' embeddedAppId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.embeddedAppId), input_name='embeddedAppId')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='PayWidget', fromsubclass_=False, pretty_print=True):
        super(PayWidget, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for method_ in self.method:
            method_.export(outfile, level, namespaceprefix_, name_='method', pretty_print=pretty_print)
        if self.baseMethod is not None:
            self.baseMethod.export(outfile, level, namespaceprefix_, name_='baseMethod', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('memo', node)
        if value is not None and 'memo' not in already_processed:
            already_processed.add('memo')
            self.memo = value
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
        value = find_attr_value_('autoSubmit', node)
        if value is not None and 'autoSubmit' not in already_processed:
            already_processed.add('autoSubmit')
            if value in ('true', '1'):
                self.autoSubmit = True
            elif value in ('false', '0'):
                self.autoSubmit = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('testMode', node)
        if value is not None and 'testMode' not in already_processed:
            already_processed.add('testMode')
            if value in ('true', '1'):
                self.testMode = True
            elif value in ('false', '0'):
                self.testMode = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('embeddedAppId', node)
        if value is not None and 'embeddedAppId' not in already_processed:
            already_processed.add('embeddedAppId')
            self.embeddedAppId = value
        super(PayWidget, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'method':
            obj_ = PaymentMethod.factory()
            obj_.build(child_)
            self.method.append(obj_)
            obj_.original_tagname_ = 'method'
        elif nodeName_ == 'baseMethod':
            class_obj_ = self.get_class_obj_(child_, BasePaymentMethod)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.baseMethod = obj_
            obj_.original_tagname_ = 'baseMethod'
        super(PayWidget, self).buildChildren(child_, node, nodeName_, True)
# end class PayWidget


class Form(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, positiveButtonCaption=None, positiveButtonConfirmation=None, negativeButtonCaption=None, negativeButtonConfirmation=None, widget=None, javascriptValidation=None):
        self.original_tagname_ = None
        self.positiveButtonCaption = _cast(None, positiveButtonCaption)
        self.positiveButtonConfirmation = _cast(None, positiveButtonConfirmation)
        self.negativeButtonCaption = _cast(None, negativeButtonCaption)
        self.negativeButtonConfirmation = _cast(None, negativeButtonConfirmation)
        self.widget = widget
        self.javascriptValidation = javascriptValidation

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Form)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Form.subclass:
            return Form.subclass(*args_, **kwargs_)
        else:
            return Form(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_widget(self): return self.widget

    def set_widget(self, widget): self.widget = widget

    def get_javascriptValidation(self): return self.javascriptValidation

    def set_javascriptValidation(self, javascriptValidation): self.javascriptValidation = javascriptValidation

    def get_positiveButtonCaption(self): return self.positiveButtonCaption

    def set_positiveButtonCaption(self, positiveButtonCaption): self.positiveButtonCaption = positiveButtonCaption

    def get_positiveButtonConfirmation(self): return self.positiveButtonConfirmation

    def set_positiveButtonConfirmation(self, positiveButtonConfirmation): self.positiveButtonConfirmation = positiveButtonConfirmation

    def get_negativeButtonCaption(self): return self.negativeButtonCaption

    def set_negativeButtonCaption(self, negativeButtonCaption): self.negativeButtonCaption = negativeButtonCaption

    def get_negativeButtonConfirmation(self): return self.negativeButtonConfirmation

    def set_negativeButtonConfirmation(self, negativeButtonConfirmation): self.negativeButtonConfirmation = negativeButtonConfirmation

    def hasContent_(self):
        if (
            self.widget is not None or
            self.javascriptValidation is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='Form', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Form')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Form')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Form', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Form'):
        if self.positiveButtonCaption is not None and 'positiveButtonCaption' not in already_processed:
            already_processed.add('positiveButtonCaption')
            outfile.write(' positiveButtonCaption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positiveButtonCaption), input_name='positiveButtonCaption')),))
        if self.positiveButtonConfirmation is not None and 'positiveButtonConfirmation' not in already_processed:
            already_processed.add('positiveButtonConfirmation')
            outfile.write(' positiveButtonConfirmation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positiveButtonConfirmation), input_name='positiveButtonConfirmation')),))
        if self.negativeButtonCaption is not None and 'negativeButtonCaption' not in already_processed:
            already_processed.add('negativeButtonCaption')
            outfile.write(' negativeButtonCaption=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.negativeButtonCaption), input_name='negativeButtonCaption')),))
        if self.negativeButtonConfirmation is not None and 'negativeButtonConfirmation' not in already_processed:
            already_processed.add('negativeButtonConfirmation')
            outfile.write(' negativeButtonConfirmation=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.negativeButtonConfirmation), input_name='negativeButtonConfirmation')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Form', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.widget is not None:
            self.widget.export(outfile, level, namespaceprefix_, name_='widget', pretty_print=pretty_print)
        if self.javascriptValidation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<javascriptValidation>%s</javascriptValidation>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.javascriptValidation), input_name='javascriptValidation')), eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('positiveButtonCaption', node)
        if value is not None and 'positiveButtonCaption' not in already_processed:
            already_processed.add('positiveButtonCaption')
            self.positiveButtonCaption = value
        value = find_attr_value_('positiveButtonConfirmation', node)
        if value is not None and 'positiveButtonConfirmation' not in already_processed:
            already_processed.add('positiveButtonConfirmation')
            self.positiveButtonConfirmation = value
        value = find_attr_value_('negativeButtonCaption', node)
        if value is not None and 'negativeButtonCaption' not in already_processed:
            already_processed.add('negativeButtonCaption')
            self.negativeButtonCaption = value
        value = find_attr_value_('negativeButtonConfirmation', node)
        if value is not None and 'negativeButtonConfirmation' not in already_processed:
            already_processed.add('negativeButtonConfirmation')
            self.negativeButtonConfirmation = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'widget':
            class_obj_ = self.get_class_obj_(child_, Widget)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.widget = obj_
            obj_.original_tagname_ = 'widget'
        elif nodeName_ == 'javascriptValidation':
            javascriptValidation_ = child_.text
            javascriptValidation_ = self.gds_validate_string(javascriptValidation_, node, 'javascriptValidation')
            self.javascriptValidation = javascriptValidation_
# end class Form


class FormMessage(FlowElement):
    subclass = None
    superclass = FlowElement

    def __init__(self, id=None, member=None, brandingKey=None, autoLock=None, vibrate=None, alertType=None, alertIntervalType=None, positiveReference=None, negativeReference=None, content=None, form=None, attachment=None):
        self.original_tagname_ = None
        super(FormMessage, self).__init__(id,)
        self.member = _cast(None, member)
        self.brandingKey = _cast(None, brandingKey)
        self.autoLock = _cast(bool, autoLock)
        self.vibrate = _cast(bool, vibrate)
        self.alertType = _cast(None, alertType)
        self.alertIntervalType = _cast(None, alertIntervalType)
        self.positiveReference = _cast(None, positiveReference)
        self.negativeReference = _cast(None, negativeReference)
        self.content = content
        self.form = form
        if attachment is None:
            self.attachment = []
        else:
            self.attachment = attachment

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FormMessage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FormMessage.subclass:
            return FormMessage.subclass(*args_, **kwargs_)
        else:
            return FormMessage(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_content(self): return self.content

    def set_content(self, content): self.content = content

    def get_form(self): return self.form

    def set_form(self, form): self.form = form

    def get_attachment(self): return self.attachment

    def set_attachment(self, attachment): self.attachment = attachment

    def add_attachment(self, value): self.attachment.append(value)

    def insert_attachment_at(self, index, value): self.attachment.insert(index, value)

    def replace_attachment_at(self, index, value): self.attachment[index] = value

    def get_member(self): return self.member

    def set_member(self, member): self.member = member

    def get_brandingKey(self): return self.brandingKey

    def set_brandingKey(self, brandingKey): self.brandingKey = brandingKey

    def get_autoLock(self): return self.autoLock

    def set_autoLock(self, autoLock): self.autoLock = autoLock

    def get_vibrate(self): return self.vibrate

    def set_vibrate(self, vibrate): self.vibrate = vibrate

    def get_alertType(self): return self.alertType

    def set_alertType(self, alertType): self.alertType = alertType

    def get_alertIntervalType(self): return self.alertIntervalType

    def set_alertIntervalType(self, alertIntervalType): self.alertIntervalType = alertIntervalType

    def get_positiveReference(self): return self.positiveReference

    def set_positiveReference(self, positiveReference): self.positiveReference = positiveReference

    def get_negativeReference(self): return self.negativeReference

    def set_negativeReference(self, negativeReference): self.negativeReference = negativeReference

    def validate_AlertType(self, value):
        # Validate type AlertType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BEEP', 'SILENT', 'RING_5', 'RING_15', 'RING_30', 'RING_60']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AlertType' % {"value" : value.encode("utf-8")})

    def validate_AlertIntervalType(self, value):
        # Validate type AlertIntervalType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NONE', 'INTERVAL_5', 'INTERVAL_15', 'INTERVAL_30', 'INTERVAL_60', 'INTERVAL_300', 'INTERVAL_900', 'INTERVAL_3600']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AlertIntervalType' % {"value" : value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.content is not None or
            self.form is not None or
            self.attachment or
            super(FormMessage, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='FormMessage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FormMessage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FormMessage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='FormMessage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FormMessage'):
        super(FormMessage, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FormMessage')
        if self.member is not None and 'member' not in already_processed:
            already_processed.add('member')
            outfile.write(' member=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.member), input_name='member')),))
        if self.brandingKey is not None and 'brandingKey' not in already_processed:
            already_processed.add('brandingKey')
            outfile.write(' brandingKey=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.brandingKey), input_name='brandingKey')),))
        if self.autoLock is not None and 'autoLock' not in already_processed:
            already_processed.add('autoLock')
            outfile.write(' autoLock="%s"' % self.gds_format_boolean(self.autoLock, input_name='autoLock'))
        if self.vibrate is not None and 'vibrate' not in already_processed:
            already_processed.add('vibrate')
            outfile.write(' vibrate="%s"' % self.gds_format_boolean(self.vibrate, input_name='vibrate'))
        if self.alertType is not None and 'alertType' not in already_processed:
            already_processed.add('alertType')
            outfile.write(' alertType=%s' % (quote_attrib(self.alertType),))
        if self.alertIntervalType is not None and 'alertIntervalType' not in already_processed:
            already_processed.add('alertIntervalType')
            outfile.write(' alertIntervalType=%s' % (quote_attrib(self.alertIntervalType),))
        if self.positiveReference is not None and 'positiveReference' not in already_processed:
            already_processed.add('positiveReference')
            outfile.write(' positiveReference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.positiveReference), input_name='positiveReference')),))
        if self.negativeReference is not None and 'negativeReference' not in already_processed:
            already_processed.add('negativeReference')
            outfile.write(' negativeReference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.negativeReference), input_name='negativeReference')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='FormMessage', fromsubclass_=False, pretty_print=True):
        super(FormMessage, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.content is not None:
            self.content.export(outfile, level, namespaceprefix_, name_='content', pretty_print=pretty_print)
        if self.form is not None:
            self.form.export(outfile, level, namespaceprefix_, name_='form', pretty_print=pretty_print)
        for attachment_ in self.attachment:
            attachment_.export(outfile, level, namespaceprefix_, name_='attachment', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('member', node)
        if value is not None and 'member' not in already_processed:
            already_processed.add('member')
            self.member = value
        value = find_attr_value_('brandingKey', node)
        if value is not None and 'brandingKey' not in already_processed:
            already_processed.add('brandingKey')
            self.brandingKey = value
        value = find_attr_value_('autoLock', node)
        if value is not None and 'autoLock' not in already_processed:
            already_processed.add('autoLock')
            if value in ('true', '1'):
                self.autoLock = True
            elif value in ('false', '0'):
                self.autoLock = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vibrate', node)
        if value is not None and 'vibrate' not in already_processed:
            already_processed.add('vibrate')
            if value in ('true', '1'):
                self.vibrate = True
            elif value in ('false', '0'):
                self.vibrate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('alertType', node)
        if value is not None and 'alertType' not in already_processed:
            already_processed.add('alertType')
            self.alertType = value
            self.validate_AlertType(self.alertType)  # validate type AlertType
        value = find_attr_value_('alertIntervalType', node)
        if value is not None and 'alertIntervalType' not in already_processed:
            already_processed.add('alertIntervalType')
            self.alertIntervalType = value
            self.validate_AlertIntervalType(self.alertIntervalType)  # validate type AlertIntervalType
        value = find_attr_value_('positiveReference', node)
        if value is not None and 'positiveReference' not in already_processed:
            already_processed.add('positiveReference')
            self.positiveReference = value
        value = find_attr_value_('negativeReference', node)
        if value is not None and 'negativeReference' not in already_processed:
            already_processed.add('negativeReference')
            self.negativeReference = value
        super(FormMessage, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            obj_ = contentType1.factory()
            obj_.build(child_)
            self.content = obj_
            obj_.original_tagname_ = 'content'
        elif nodeName_ == 'form':
            obj_ = Form.factory()
            obj_.build(child_)
            self.form = obj_
            obj_.original_tagname_ = 'form'
        elif nodeName_ == 'attachment':
            obj_ = Attachment.factory()
            obj_.build(child_)
            self.attachment.append(obj_)
            obj_.original_tagname_ = 'attachment'
        super(FormMessage, self).buildChildren(child_, node, nodeName_, True)
# end class FormMessage


class Outlet(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, value=None, name=None, reference=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.name = _cast(None, name)
        self.reference = _cast(None, reference)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Outlet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Outlet.subclass:
            return Outlet.subclass(*args_, **kwargs_)
        else:
            return Outlet(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def get_name(self): return self.name

    def set_name(self, name): self.name = name

    def get_reference(self): return self.reference

    def set_reference(self, reference): self.reference = reference

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='Outlet', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Outlet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Outlet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Outlet', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Outlet'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')),))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Outlet', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Outlet


class End(FlowElement):
    subclass = None
    superclass = FlowElement

    def __init__(self, id=None, waitForFollowUpMessage=False):
        self.original_tagname_ = None
        super(End, self).__init__(id,)
        self.waitForFollowUpMessage = _cast(bool, waitForFollowUpMessage)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, End)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if End.subclass:
            return End.subclass(*args_, **kwargs_)
        else:
            return End(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_waitForFollowUpMessage(self): return self.waitForFollowUpMessage

    def set_waitForFollowUpMessage(self, waitForFollowUpMessage): self.waitForFollowUpMessage = waitForFollowUpMessage

    def hasContent_(self):
        if (
            super(End, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='End', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('End')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='End')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='End', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='End'):
        super(End, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='End')
        if self.waitForFollowUpMessage and 'waitForFollowUpMessage' not in already_processed:
            already_processed.add('waitForFollowUpMessage')
            outfile.write(' waitForFollowUpMessage="%s"' % self.gds_format_boolean(self.waitForFollowUpMessage, input_name='waitForFollowUpMessage'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='End', fromsubclass_=False, pretty_print=True):
        super(End, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('waitForFollowUpMessage', node)
        if value is not None and 'waitForFollowUpMessage' not in already_processed:
            already_processed.add('waitForFollowUpMessage')
            if value in ('true', '1'):
                self.waitForFollowUpMessage = True
            elif value in ('false', '0'):
                self.waitForFollowUpMessage = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(End, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(End, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class End


class MessageFlowDefinition(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, name=None, startReference=None, language=None, end=None, message=None, formMessage=None, resultsFlush=None, resultsEmail=None, flowCode=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.startReference = _cast(None, startReference)
        self.language = _cast(None, language)
        if end is None:
            self.end = []
        else:
            self.end = end
        if message is None:
            self.message = []
        else:
            self.message = message
        if formMessage is None:
            self.formMessage = []
        else:
            self.formMessage = formMessage
        if resultsFlush is None:
            self.resultsFlush = []
        else:
            self.resultsFlush = resultsFlush
        if resultsEmail is None:
            self.resultsEmail = []
        else:
            self.resultsEmail = resultsEmail
        if flowCode is None:
            self.flowCode = []
        else:
            self.flowCode = flowCode

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageFlowDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageFlowDefinition.subclass:
            return MessageFlowDefinition.subclass(*args_, **kwargs_)
        else:
            return MessageFlowDefinition(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_end(self): return self.end

    def set_end(self, end): self.end = end

    def add_end(self, value): self.end.append(value)

    def insert_end_at(self, index, value): self.end.insert(index, value)

    def replace_end_at(self, index, value): self.end[index] = value

    def get_message(self): return self.message

    def set_message(self, message): self.message = message

    def add_message(self, value): self.message.append(value)

    def insert_message_at(self, index, value): self.message.insert(index, value)

    def replace_message_at(self, index, value): self.message[index] = value

    def get_formMessage(self): return self.formMessage

    def set_formMessage(self, formMessage): self.formMessage = formMessage

    def add_formMessage(self, value): self.formMessage.append(value)

    def insert_formMessage_at(self, index, value): self.formMessage.insert(index, value)

    def replace_formMessage_at(self, index, value): self.formMessage[index] = value

    def get_resultsFlush(self): return self.resultsFlush

    def set_resultsFlush(self, resultsFlush): self.resultsFlush = resultsFlush

    def add_resultsFlush(self, value): self.resultsFlush.append(value)

    def insert_resultsFlush_at(self, index, value): self.resultsFlush.insert(index, value)

    def replace_resultsFlush_at(self, index, value): self.resultsFlush[index] = value

    def get_resultsEmail(self): return self.resultsEmail

    def set_resultsEmail(self, resultsEmail): self.resultsEmail = resultsEmail

    def add_resultsEmail(self, value): self.resultsEmail.append(value)

    def insert_resultsEmail_at(self, index, value): self.resultsEmail.insert(index, value)

    def replace_resultsEmail_at(self, index, value): self.resultsEmail[index] = value

    def get_flowCode(self): return self.flowCode

    def set_flowCode(self, flowCode): self.flowCode = flowCode

    def add_flowCode(self, value): self.flowCode.append(value)

    def insert_flowCode_at(self, index, value): self.flowCode.insert(index, value)

    def replace_flowCode_at(self, index, value): self.flowCode[index] = value

    def get_name(self): return self.name

    def set_name(self, name): self.name = name

    def get_startReference(self): return self.startReference

    def set_startReference(self, startReference): self.startReference = startReference

    def get_language(self): return self.language

    def set_language(self, language): self.language = language

    def hasContent_(self):
        if (
            self.end or
            self.message or
            self.formMessage or
            self.resultsFlush or
            self.resultsEmail or
            self.flowCode
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MessageFlowDefinition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageFlowDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageFlowDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MessageFlowDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessageFlowDefinition'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.startReference is not None and 'startReference' not in already_processed:
            already_processed.add('startReference')
            outfile.write(' startReference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.startReference), input_name='startReference')),))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MessageFlowDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for end_ in self.end:
            end_.export(outfile, level, namespaceprefix_, name_='end', pretty_print=pretty_print)
        for message_ in self.message:
            message_.export(outfile, level, namespaceprefix_, name_='message', pretty_print=pretty_print)
        for formMessage_ in self.formMessage:
            formMessage_.export(outfile, level, namespaceprefix_, name_='formMessage', pretty_print=pretty_print)
        for resultsFlush_ in self.resultsFlush:
            resultsFlush_.export(outfile, level, namespaceprefix_, name_='resultsFlush', pretty_print=pretty_print)
        for resultsEmail_ in self.resultsEmail:
            resultsEmail_.export(outfile, level, namespaceprefix_, name_='resultsEmail', pretty_print=pretty_print)
        for flowCode_ in self.flowCode:
            flowCode_.export(outfile, level, namespaceprefix_, name_='flowCode', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('startReference', node)
        if value is not None and 'startReference' not in already_processed:
            already_processed.add('startReference')
            self.startReference = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'end':
            obj_ = End.factory()
            obj_.build(child_)
            self.end.append(obj_)
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'message':
            obj_ = Message.factory()
            obj_.build(child_)
            self.message.append(obj_)
            obj_.original_tagname_ = 'message'
        elif nodeName_ == 'formMessage':
            obj_ = FormMessage.factory()
            obj_.build(child_)
            self.formMessage.append(obj_)
            obj_.original_tagname_ = 'formMessage'
        elif nodeName_ == 'resultsFlush':
            obj_ = ResultsFlush.factory()
            obj_.build(child_)
            self.resultsFlush.append(obj_)
            obj_.original_tagname_ = 'resultsFlush'
        elif nodeName_ == 'resultsEmail':
            obj_ = ResultsEmail.factory()
            obj_.build(child_)
            self.resultsEmail.append(obj_)
            obj_.original_tagname_ = 'resultsEmail'
        elif nodeName_ == 'flowCode':
            obj_ = FlowCode.factory()
            obj_.build(child_)
            self.flowCode.append(obj_)
            obj_.original_tagname_ = 'flowCode'
# end class MessageFlowDefinition


class MessageFlowDefinitionSet(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, definition=None):
        self.original_tagname_ = None
        if definition is None:
            self.definition = []
        else:
            self.definition = definition

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageFlowDefinitionSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageFlowDefinitionSet.subclass:
            return MessageFlowDefinitionSet.subclass(*args_, **kwargs_)
        else:
            return MessageFlowDefinitionSet(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_definition(self): return self.definition

    def set_definition(self, definition): self.definition = definition

    def add_definition(self, value): self.definition.append(value)

    def insert_definition_at(self, index, value): self.definition.insert(index, value)

    def replace_definition_at(self, index, value): self.definition[index] = value

    def hasContent_(self):
        if (
            self.definition
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MessageFlowDefinitionSet', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageFlowDefinitionSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageFlowDefinitionSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MessageFlowDefinitionSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessageFlowDefinitionSet'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MessageFlowDefinitionSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for definition_ in self.definition:
            definition_.export(outfile, level, namespaceprefix_, name_='definition', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'definition':
            obj_ = MessageFlowDefinition.factory()
            obj_.build(child_)
            self.definition.append(obj_)
            obj_.original_tagname_ = 'definition'
# end class MessageFlowDefinitionSet


class Step(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.creationTimestamp = _cast(int, creationTimestamp)
        self.definition = _cast(None, definition)
        self.previousStep = _cast(None, previousStep)
        self.nextStep = _cast(None, nextStep)
        self.message = _cast(None, message)
        self.button = _cast(None, button)
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Step)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Step.subclass:
            return Step.subclass(*args_, **kwargs_)
        else:
            return Step(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_id(self): return self.id

    def set_id(self, id): self.id = id

    def get_creationTimestamp(self): return self.creationTimestamp

    def set_creationTimestamp(self, creationTimestamp): self.creationTimestamp = creationTimestamp

    def get_definition(self): return self.definition

    def set_definition(self, definition): self.definition = definition

    def get_previousStep(self): return self.previousStep

    def set_previousStep(self, previousStep): self.previousStep = previousStep

    def get_nextStep(self): return self.nextStep

    def set_nextStep(self, nextStep): self.nextStep = nextStep

    def get_message(self): return self.message

    def set_message(self, message): self.message = message

    def get_button(self): return self.button

    def set_button(self, button): self.button = button

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='Step', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Step')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Step')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='Step', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Step'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')),))
        if self.creationTimestamp is not None and 'creationTimestamp' not in already_processed:
            already_processed.add('creationTimestamp')
            outfile.write(' creationTimestamp="%s"' % self.gds_format_integer(self.creationTimestamp, input_name='creationTimestamp'))
        if self.definition is not None and 'definition' not in already_processed:
            already_processed.add('definition')
            outfile.write(' definition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.definition), input_name='definition')),))
        if self.previousStep is not None and 'previousStep' not in already_processed:
            already_processed.add('previousStep')
            outfile.write(' previousStep=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.previousStep), input_name='previousStep')),))
        if self.nextStep is not None and 'nextStep' not in already_processed:
            already_processed.add('nextStep')
            outfile.write(' nextStep=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nextStep), input_name='nextStep')),))
        if self.message is not None and 'message' not in already_processed:
            already_processed.add('message')
            outfile.write(' message=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.message), input_name='message')),))
        if self.button is not None and 'button' not in already_processed:
            already_processed.add('button')
            outfile.write(' button=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.button), input_name='button')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Step', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('creationTimestamp', node)
        if value is not None and 'creationTimestamp' not in already_processed:
            already_processed.add('creationTimestamp')
            try:
                self.creationTimestamp = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('definition', node)
        if value is not None and 'definition' not in already_processed:
            already_processed.add('definition')
            self.definition = value
        value = find_attr_value_('previousStep', node)
        if value is not None and 'previousStep' not in already_processed:
            already_processed.add('previousStep')
            self.previousStep = value
        value = find_attr_value_('nextStep', node)
        if value is not None and 'nextStep' not in already_processed:
            already_processed.add('nextStep')
            self.nextStep = value
        value = find_attr_value_('message', node)
        if value is not None and 'message' not in already_processed:
            already_processed.add('message')
            self.message = value
        value = find_attr_value_('button', node)
        if value is not None and 'button' not in already_processed:
            already_processed.add('button')
            self.button = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Step


class BaseMessageStep(Step):
    subclass = None
    superclass = Step

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, extensiontype_=None):
        self.original_tagname_ = None
        super(BaseMessageStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, extensiontype_,)
        self.receivedTimestamp = _cast(int, receivedTimestamp)
        self.acknowledgedTimestamp = _cast(int, acknowledgedTimestamp)
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseMessageStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseMessageStep.subclass:
            return BaseMessageStep.subclass(*args_, **kwargs_)
        else:
            return BaseMessageStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_receivedTimestamp(self): return self.receivedTimestamp

    def set_receivedTimestamp(self, receivedTimestamp): self.receivedTimestamp = receivedTimestamp

    def get_acknowledgedTimestamp(self): return self.acknowledgedTimestamp

    def set_acknowledgedTimestamp(self, acknowledgedTimestamp): self.acknowledgedTimestamp = acknowledgedTimestamp

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
            super(BaseMessageStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='BaseMessageStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseMessageStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseMessageStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='BaseMessageStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseMessageStep'):
        super(BaseMessageStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseMessageStep')
        if self.receivedTimestamp is not None and 'receivedTimestamp' not in already_processed:
            already_processed.add('receivedTimestamp')
            outfile.write(' receivedTimestamp="%s"' % self.gds_format_integer(self.receivedTimestamp, input_name='receivedTimestamp'))
        if self.acknowledgedTimestamp is not None and 'acknowledgedTimestamp' not in already_processed:
            already_processed.add('acknowledgedTimestamp')
            outfile.write(' acknowledgedTimestamp="%s"' % self.gds_format_integer(self.acknowledgedTimestamp, input_name='acknowledgedTimestamp'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BaseMessageStep', fromsubclass_=False, pretty_print=True):
        super(BaseMessageStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('receivedTimestamp', node)
        if value is not None and 'receivedTimestamp' not in already_processed:
            already_processed.add('receivedTimestamp')
            try:
                self.receivedTimestamp = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('acknowledgedTimestamp', node)
        if value is not None and 'acknowledgedTimestamp' not in already_processed:
            already_processed.add('acknowledgedTimestamp')
            try:
                self.acknowledgedTimestamp = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseMessageStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BaseMessageStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseMessageStep


class MessageStep(BaseMessageStep):
    subclass = None
    superclass = BaseMessageStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, answer=None):
        self.original_tagname_ = None
        super(MessageStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp,)
        self.answer = _cast(None, answer)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageStep.subclass:
            return MessageStep.subclass(*args_, **kwargs_)
        else:
            return MessageStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_answer(self): return self.answer

    def set_answer(self, answer): self.answer = answer

    def hasContent_(self):
        if (
            super(MessageStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MessageStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MessageStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessageStep'):
        super(MessageStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageStep')
        if self.answer is not None and 'answer' not in already_processed:
            already_processed.add('answer')
            outfile.write(' answer=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.answer), input_name='answer')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MessageStep', fromsubclass_=False, pretty_print=True):
        super(MessageStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('answer', node)
        if value is not None and 'answer' not in already_processed:
            already_processed.add('answer')
            self.answer = value
        super(MessageStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MessageStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MessageStep


class WidgetStep(BaseMessageStep):
    subclass = None
    superclass = BaseMessageStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, extensiontype_=None):
        self.original_tagname_ = None
        super(WidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, extensiontype_,)
        self.displayValue = _cast(None, displayValue)
        self.formButton = _cast(None, formButton)
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WidgetStep.subclass:
            return WidgetStep.subclass(*args_, **kwargs_)
        else:
            return WidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_displayValue(self): return self.displayValue

    def set_displayValue(self, displayValue): self.displayValue = displayValue

    def get_formButton(self): return self.formButton

    def set_formButton(self, formButton): self.formButton = formButton

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def validate_FormButton(self, value):
        # Validate type FormButton, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['positive', 'negative']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on FormButton' % {"value" : value.encode("utf-8")})

    def hasContent_(self):
        if (
            super(WidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='WidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='WidgetStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WidgetStep'):
        super(WidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WidgetStep')
        if self.displayValue is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            outfile.write(' displayValue=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.displayValue), input_name='displayValue')),))
        if self.formButton is not None and 'formButton' not in already_processed:
            already_processed.add('formButton')
            outfile.write(' formButton=%s' % (quote_attrib(self.formButton),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='WidgetStep', fromsubclass_=False, pretty_print=True):
        super(WidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('displayValue', node)
        if value is not None and 'displayValue' not in already_processed:
            already_processed.add('displayValue')
            self.displayValue = value
        value = find_attr_value_('formButton', node)
        if value is not None and 'formButton' not in already_processed:
            already_processed.add('formButton')
            self.formButton = value
            self.validate_FormButton(self.formButton)  # validate type FormButton
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(WidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WidgetStep


class TextWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, value=None, extensiontype_=None):
        self.original_tagname_ = None
        super(TextWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton, extensiontype_,)
        self.value = _cast(None, value)
        self.extensiontype_ = extensiontype_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextWidgetStep.subclass:
            return TextWidgetStep.subclass(*args_, **kwargs_)
        else:
            return TextWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def get_extensiontype_(self): return self.extensiontype_

    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_

    def hasContent_(self):
        if (
            super(TextWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='TextWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TextWidgetStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextWidgetStep'):
        super(TextWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextWidgetStep')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')),))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TextWidgetStep', fromsubclass_=False, pretty_print=True):
        super(TextWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(TextWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextWidgetStep


class TextLineWidgetStep(TextWidgetStep):
    subclass = None
    superclass = TextWidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, value=None):
        self.original_tagname_ = None
        super(TextLineWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton, value,)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextLineWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextLineWidgetStep.subclass:
            return TextLineWidgetStep.subclass(*args_, **kwargs_)
        else:
            return TextLineWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def hasContent_(self):
        if (
            super(TextLineWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='TextLineWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextLineWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextLineWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TextLineWidgetStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextLineWidgetStep'):
        super(TextLineWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextLineWidgetStep')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TextLineWidgetStep', fromsubclass_=False, pretty_print=True):
        super(TextLineWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(TextLineWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextLineWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextLineWidgetStep


class TextBlockWidgetStep(TextWidgetStep):
    subclass = None
    superclass = TextWidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, value=None):
        self.original_tagname_ = None
        super(TextBlockWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton, value,)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextBlockWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextBlockWidgetStep.subclass:
            return TextBlockWidgetStep.subclass(*args_, **kwargs_)
        else:
            return TextBlockWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def hasContent_(self):
        if (
            super(TextBlockWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='TextBlockWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextBlockWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBlockWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TextBlockWidgetStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextBlockWidgetStep'):
        super(TextBlockWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextBlockWidgetStep')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TextBlockWidgetStep', fromsubclass_=False, pretty_print=True):
        super(TextBlockWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(TextBlockWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextBlockWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextBlockWidgetStep


class TextAutoCompleteWidgetStep(TextWidgetStep):
    subclass = None
    superclass = TextWidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, value=None):
        self.original_tagname_ = None
        super(TextAutoCompleteWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton, value,)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextAutoCompleteWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextAutoCompleteWidgetStep.subclass:
            return TextAutoCompleteWidgetStep.subclass(*args_, **kwargs_)
        else:
            return TextAutoCompleteWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def hasContent_(self):
        if (
            super(TextAutoCompleteWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='TextAutoCompleteWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextAutoCompleteWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextAutoCompleteWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='TextAutoCompleteWidgetStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextAutoCompleteWidgetStep'):
        super(TextAutoCompleteWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextAutoCompleteWidgetStep')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TextAutoCompleteWidgetStep', fromsubclass_=False, pretty_print=True):
        super(TextAutoCompleteWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(TextAutoCompleteWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextAutoCompleteWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextAutoCompleteWidgetStep


class SliderWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, value=None):
        self.original_tagname_ = None
        super(SliderWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton,)
        self.value = _cast(float, value)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SliderWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SliderWidgetStep.subclass:
            return SliderWidgetStep.subclass(*args_, **kwargs_)
        else:
            return SliderWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def hasContent_(self):
        if (
            super(SliderWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SliderWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SliderWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SliderWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SliderWidgetStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SliderWidgetStep'):
        super(SliderWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SliderWidgetStep')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_float(self.value, input_name='value'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SliderWidgetStep', fromsubclass_=False, pretty_print=True):
        super(SliderWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        super(SliderWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SliderWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SliderWidgetStep


class RangeSliderWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, value=None):
        self.original_tagname_ = None
        super(RangeSliderWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton,)
        if value is None:
            self.value = []
        else:
            self.value = value

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RangeSliderWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RangeSliderWidgetStep.subclass:
            return RangeSliderWidgetStep.subclass(*args_, **kwargs_)
        else:
            return RangeSliderWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def add_value(self, value): self.value.append(value)

    def insert_value_at(self, index, value): self.value.insert(index, value)

    def replace_value_at(self, index, value): self.value[index] = value

    def hasContent_(self):
        if (
            self.value or
            super(RangeSliderWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='RangeSliderWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RangeSliderWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RangeSliderWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='RangeSliderWidgetStep', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RangeSliderWidgetStep'):
        super(RangeSliderWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RangeSliderWidgetStep')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='RangeSliderWidgetStep', fromsubclass_=False, pretty_print=True):
        super(RangeSliderWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            value_.export(outfile, level, namespaceprefix_, name_='value', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(RangeSliderWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            obj_ = FloatValue.factory()
            obj_.build(child_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
        super(RangeSliderWidgetStep, self).buildChildren(child_, node, nodeName_, True)
# end class RangeSliderWidgetStep


class PhotoUploadWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, value=None):
        self.original_tagname_ = None
        super(PhotoUploadWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton,)
        self.value = _cast(None, value)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhotoUploadWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhotoUploadWidgetStep.subclass:
            return PhotoUploadWidgetStep.subclass(*args_, **kwargs_)
        else:
            return PhotoUploadWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def hasContent_(self):
        if (
            super(PhotoUploadWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='PhotoUploadWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhotoUploadWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhotoUploadWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='PhotoUploadWidgetStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhotoUploadWidgetStep'):
        super(PhotoUploadWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhotoUploadWidgetStep')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='PhotoUploadWidgetStep', fromsubclass_=False, pretty_print=True):
        super(PhotoUploadWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(PhotoUploadWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PhotoUploadWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PhotoUploadWidgetStep


class GPSLocationWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, horizontalAccuracy=None, verticalAccuracy=None, latitude=None, longitude=None, altitude=None, timestamp=None):
        self.original_tagname_ = None
        super(GPSLocationWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton,)
        self.horizontalAccuracy = _cast(float, horizontalAccuracy)
        self.verticalAccuracy = _cast(float, verticalAccuracy)
        self.latitude = _cast(float, latitude)
        self.longitude = _cast(float, longitude)
        self.altitude = _cast(float, altitude)
        self.timestamp = _cast(int, timestamp)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GPSLocationWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GPSLocationWidgetStep.subclass:
            return GPSLocationWidgetStep.subclass(*args_, **kwargs_)
        else:
            return GPSLocationWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_horizontalAccuracy(self): return self.horizontalAccuracy

    def set_horizontalAccuracy(self, horizontalAccuracy): self.horizontalAccuracy = horizontalAccuracy

    def get_verticalAccuracy(self): return self.verticalAccuracy

    def set_verticalAccuracy(self, verticalAccuracy): self.verticalAccuracy = verticalAccuracy

    def get_latitude(self): return self.latitude

    def set_latitude(self, latitude): self.latitude = latitude

    def get_longitude(self): return self.longitude

    def set_longitude(self, longitude): self.longitude = longitude

    def get_altitude(self): return self.altitude

    def set_altitude(self, altitude): self.altitude = altitude

    def get_timestamp(self): return self.timestamp

    def set_timestamp(self, timestamp): self.timestamp = timestamp

    def hasContent_(self):
        if (
            super(GPSLocationWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='GPSLocationWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GPSLocationWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GPSLocationWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='GPSLocationWidgetStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GPSLocationWidgetStep'):
        super(GPSLocationWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GPSLocationWidgetStep')
        if self.horizontalAccuracy is not None and 'horizontalAccuracy' not in already_processed:
            already_processed.add('horizontalAccuracy')
            outfile.write(' horizontalAccuracy="%s"' % self.gds_format_float(self.horizontalAccuracy, input_name='horizontalAccuracy'))
        if self.verticalAccuracy is not None and 'verticalAccuracy' not in already_processed:
            already_processed.add('verticalAccuracy')
            outfile.write(' verticalAccuracy="%s"' % self.gds_format_float(self.verticalAccuracy, input_name='verticalAccuracy'))
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            outfile.write(' latitude="%s"' % self.gds_format_float(self.latitude, input_name='latitude'))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            outfile.write(' longitude="%s"' % self.gds_format_float(self.longitude, input_name='longitude'))
        if self.altitude is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            outfile.write(' altitude="%s"' % self.gds_format_float(self.altitude, input_name='altitude'))
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp="%s"' % self.gds_format_integer(self.timestamp, input_name='timestamp'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='GPSLocationWidgetStep', fromsubclass_=False, pretty_print=True):
        super(GPSLocationWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('horizontalAccuracy', node)
        if value is not None and 'horizontalAccuracy' not in already_processed:
            already_processed.add('horizontalAccuracy')
            try:
                self.horizontalAccuracy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (horizontalAccuracy): %s' % exp)
        value = find_attr_value_('verticalAccuracy', node)
        if value is not None and 'verticalAccuracy' not in already_processed:
            already_processed.add('verticalAccuracy')
            try:
                self.verticalAccuracy = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (verticalAccuracy): %s' % exp)
        value = find_attr_value_('latitude', node)
        if value is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            try:
                self.latitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (latitude): %s' % exp)
        value = find_attr_value_('longitude', node)
        if value is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            try:
                self.longitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (longitude): %s' % exp)
        value = find_attr_value_('altitude', node)
        if value is not None and 'altitude' not in already_processed:
            already_processed.add('altitude')
            try:
                self.altitude = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (altitude): %s' % exp)
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(GPSLocationWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GPSLocationWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GPSLocationWidgetStep


class MyDigiPassEidProfile(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, firstName=None, firstName3=None, lastName=None, gender=None, nationality=None, dateOfBirth=None, locationOfBirth=None, nobleCondition=None, issuingMunicipality=None, cardNumber=None, chipNumber=None, validityBeginsAt=None, validityEndsAt=None, createdAt=None):
        self.original_tagname_ = None
        self.firstName = _cast(None, firstName)
        self.firstName3 = _cast(None, firstName3)
        self.lastName = _cast(None, lastName)
        self.gender = _cast(None, gender)
        self.nationality = _cast(None, nationality)
        self.dateOfBirth = _cast(None, dateOfBirth)
        self.locationOfBirth = _cast(None, locationOfBirth)
        self.nobleCondition = _cast(None, nobleCondition)
        self.issuingMunicipality = _cast(None, issuingMunicipality)
        self.cardNumber = _cast(None, cardNumber)
        self.chipNumber = _cast(None, chipNumber)
        self.validityBeginsAt = _cast(None, validityBeginsAt)
        self.validityEndsAt = _cast(None, validityEndsAt)
        self.createdAt = _cast(None, createdAt)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MyDigiPassEidProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MyDigiPassEidProfile.subclass:
            return MyDigiPassEidProfile.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassEidProfile(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_firstName(self): return self.firstName

    def set_firstName(self, firstName): self.firstName = firstName

    def get_firstName3(self): return self.firstName3

    def set_firstName3(self, firstName3): self.firstName3 = firstName3

    def get_lastName(self): return self.lastName

    def set_lastName(self, lastName): self.lastName = lastName

    def get_gender(self): return self.gender

    def set_gender(self, gender): self.gender = gender

    def get_nationality(self): return self.nationality

    def set_nationality(self, nationality): self.nationality = nationality

    def get_dateOfBirth(self): return self.dateOfBirth

    def set_dateOfBirth(self, dateOfBirth): self.dateOfBirth = dateOfBirth

    def get_locationOfBirth(self): return self.locationOfBirth

    def set_locationOfBirth(self, locationOfBirth): self.locationOfBirth = locationOfBirth

    def get_nobleCondition(self): return self.nobleCondition

    def set_nobleCondition(self, nobleCondition): self.nobleCondition = nobleCondition

    def get_issuingMunicipality(self): return self.issuingMunicipality

    def set_issuingMunicipality(self, issuingMunicipality): self.issuingMunicipality = issuingMunicipality

    def get_cardNumber(self): return self.cardNumber

    def set_cardNumber(self, cardNumber): self.cardNumber = cardNumber

    def get_chipNumber(self): return self.chipNumber

    def set_chipNumber(self, chipNumber): self.chipNumber = chipNumber

    def get_validityBeginsAt(self): return self.validityBeginsAt

    def set_validityBeginsAt(self, validityBeginsAt): self.validityBeginsAt = validityBeginsAt

    def get_validityEndsAt(self): return self.validityEndsAt

    def set_validityEndsAt(self, validityEndsAt): self.validityEndsAt = validityEndsAt

    def get_createdAt(self): return self.createdAt

    def set_createdAt(self, createdAt): self.createdAt = createdAt

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MyDigiPassEidProfile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MyDigiPassEidProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MyDigiPassEidProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MyDigiPassEidProfile', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MyDigiPassEidProfile'):
        if self.firstName is not None and 'firstName' not in already_processed:
            already_processed.add('firstName')
            outfile.write(' firstName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.firstName), input_name='firstName')),))
        if self.firstName3 is not None and 'firstName3' not in already_processed:
            already_processed.add('firstName3')
            outfile.write(' firstName3=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.firstName3), input_name='firstName3')),))
        if self.lastName is not None and 'lastName' not in already_processed:
            already_processed.add('lastName')
            outfile.write(' lastName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lastName), input_name='lastName')),))
        if self.gender is not None and 'gender' not in already_processed:
            already_processed.add('gender')
            outfile.write(' gender=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gender), input_name='gender')),))
        if self.nationality is not None and 'nationality' not in already_processed:
            already_processed.add('nationality')
            outfile.write(' nationality=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nationality), input_name='nationality')),))
        if self.dateOfBirth is not None and 'dateOfBirth' not in already_processed:
            already_processed.add('dateOfBirth')
            outfile.write(' dateOfBirth=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dateOfBirth), input_name='dateOfBirth')),))
        if self.locationOfBirth is not None and 'locationOfBirth' not in already_processed:
            already_processed.add('locationOfBirth')
            outfile.write(' locationOfBirth=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.locationOfBirth), input_name='locationOfBirth')),))
        if self.nobleCondition is not None and 'nobleCondition' not in already_processed:
            already_processed.add('nobleCondition')
            outfile.write(' nobleCondition=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nobleCondition), input_name='nobleCondition')),))
        if self.issuingMunicipality is not None and 'issuingMunicipality' not in already_processed:
            already_processed.add('issuingMunicipality')
            outfile.write(' issuingMunicipality=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.issuingMunicipality), input_name='issuingMunicipality')),))
        if self.cardNumber is not None and 'cardNumber' not in already_processed:
            already_processed.add('cardNumber')
            outfile.write(' cardNumber=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cardNumber), input_name='cardNumber')),))
        if self.chipNumber is not None and 'chipNumber' not in already_processed:
            already_processed.add('chipNumber')
            outfile.write(' chipNumber=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.chipNumber), input_name='chipNumber')),))
        if self.validityBeginsAt is not None and 'validityBeginsAt' not in already_processed:
            already_processed.add('validityBeginsAt')
            outfile.write(' validityBeginsAt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.validityBeginsAt), input_name='validityBeginsAt')),))
        if self.validityEndsAt is not None and 'validityEndsAt' not in already_processed:
            already_processed.add('validityEndsAt')
            outfile.write(' validityEndsAt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.validityEndsAt), input_name='validityEndsAt')),))
        if self.createdAt is not None and 'createdAt' not in already_processed:
            already_processed.add('createdAt')
            outfile.write(' createdAt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.createdAt), input_name='createdAt')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MyDigiPassEidProfile', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('firstName', node)
        if value is not None and 'firstName' not in already_processed:
            already_processed.add('firstName')
            self.firstName = value
        value = find_attr_value_('firstName3', node)
        if value is not None and 'firstName3' not in already_processed:
            already_processed.add('firstName3')
            self.firstName3 = value
        value = find_attr_value_('lastName', node)
        if value is not None and 'lastName' not in already_processed:
            already_processed.add('lastName')
            self.lastName = value
        value = find_attr_value_('gender', node)
        if value is not None and 'gender' not in already_processed:
            already_processed.add('gender')
            self.gender = value
        value = find_attr_value_('nationality', node)
        if value is not None and 'nationality' not in already_processed:
            already_processed.add('nationality')
            self.nationality = value
        value = find_attr_value_('dateOfBirth', node)
        if value is not None and 'dateOfBirth' not in already_processed:
            already_processed.add('dateOfBirth')
            self.dateOfBirth = value
        value = find_attr_value_('locationOfBirth', node)
        if value is not None and 'locationOfBirth' not in already_processed:
            already_processed.add('locationOfBirth')
            self.locationOfBirth = value
        value = find_attr_value_('nobleCondition', node)
        if value is not None and 'nobleCondition' not in already_processed:
            already_processed.add('nobleCondition')
            self.nobleCondition = value
        value = find_attr_value_('issuingMunicipality', node)
        if value is not None and 'issuingMunicipality' not in already_processed:
            already_processed.add('issuingMunicipality')
            self.issuingMunicipality = value
        value = find_attr_value_('cardNumber', node)
        if value is not None and 'cardNumber' not in already_processed:
            already_processed.add('cardNumber')
            self.cardNumber = value
        value = find_attr_value_('chipNumber', node)
        if value is not None and 'chipNumber' not in already_processed:
            already_processed.add('chipNumber')
            self.chipNumber = value
        value = find_attr_value_('validityBeginsAt', node)
        if value is not None and 'validityBeginsAt' not in already_processed:
            already_processed.add('validityBeginsAt')
            self.validityBeginsAt = value
        value = find_attr_value_('validityEndsAt', node)
        if value is not None and 'validityEndsAt' not in already_processed:
            already_processed.add('validityEndsAt')
            self.validityEndsAt = value
        value = find_attr_value_('createdAt', node)
        if value is not None and 'createdAt' not in already_processed:
            already_processed.add('createdAt')
            self.createdAt = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MyDigiPassEidProfile


class MyDigiPassEidAddress(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, streetAndNumber=None, zipCode=None, municipality=None):
        self.original_tagname_ = None
        self.streetAndNumber = _cast(None, streetAndNumber)
        self.zipCode = _cast(None, zipCode)
        self.municipality = _cast(None, municipality)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MyDigiPassEidAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MyDigiPassEidAddress.subclass:
            return MyDigiPassEidAddress.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassEidAddress(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_streetAndNumber(self): return self.streetAndNumber

    def set_streetAndNumber(self, streetAndNumber): self.streetAndNumber = streetAndNumber

    def get_zipCode(self): return self.zipCode

    def set_zipCode(self, zipCode): self.zipCode = zipCode

    def get_municipality(self): return self.municipality

    def set_municipality(self, municipality): self.municipality = municipality

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MyDigiPassEidAddress', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MyDigiPassEidAddress')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MyDigiPassEidAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MyDigiPassEidAddress', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MyDigiPassEidAddress'):
        if self.streetAndNumber is not None and 'streetAndNumber' not in already_processed:
            already_processed.add('streetAndNumber')
            outfile.write(' streetAndNumber=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.streetAndNumber), input_name='streetAndNumber')),))
        if self.zipCode is not None and 'zipCode' not in already_processed:
            already_processed.add('zipCode')
            outfile.write(' zipCode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.zipCode), input_name='zipCode')),))
        if self.municipality is not None and 'municipality' not in already_processed:
            already_processed.add('municipality')
            outfile.write(' municipality=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.municipality), input_name='municipality')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MyDigiPassEidAddress', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('streetAndNumber', node)
        if value is not None and 'streetAndNumber' not in already_processed:
            already_processed.add('streetAndNumber')
            self.streetAndNumber = value
        value = find_attr_value_('zipCode', node)
        if value is not None and 'zipCode' not in already_processed:
            already_processed.add('zipCode')
            self.zipCode = value
        value = find_attr_value_('municipality', node)
        if value is not None and 'municipality' not in already_processed:
            already_processed.add('municipality')
            self.municipality = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MyDigiPassEidAddress


class MyDigiPassProfile(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, updatedAt=None, firstName=None, lastName=None, bornOn=None, preferredLocale=None, uuid=None):
        self.original_tagname_ = None
        self.updatedAt = _cast(None, updatedAt)
        self.firstName = _cast(None, firstName)
        self.lastName = _cast(None, lastName)
        self.bornOn = _cast(None, bornOn)
        self.preferredLocale = _cast(None, preferredLocale)
        self.uuid = _cast(None, uuid)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MyDigiPassProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MyDigiPassProfile.subclass:
            return MyDigiPassProfile.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassProfile(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_updatedAt(self): return self.updatedAt

    def set_updatedAt(self, updatedAt): self.updatedAt = updatedAt

    def get_firstName(self): return self.firstName

    def set_firstName(self, firstName): self.firstName = firstName

    def get_lastName(self): return self.lastName

    def set_lastName(self, lastName): self.lastName = lastName

    def get_bornOn(self): return self.bornOn

    def set_bornOn(self, bornOn): self.bornOn = bornOn

    def get_preferredLocale(self): return self.preferredLocale

    def set_preferredLocale(self, preferredLocale): self.preferredLocale = preferredLocale

    def get_uuid(self): return self.uuid

    def set_uuid(self, uuid): self.uuid = uuid

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MyDigiPassProfile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MyDigiPassProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MyDigiPassProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MyDigiPassProfile', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MyDigiPassProfile'):
        if self.updatedAt is not None and 'updatedAt' not in already_processed:
            already_processed.add('updatedAt')
            outfile.write(' updatedAt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.updatedAt), input_name='updatedAt')),))
        if self.firstName is not None and 'firstName' not in already_processed:
            already_processed.add('firstName')
            outfile.write(' firstName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.firstName), input_name='firstName')),))
        if self.lastName is not None and 'lastName' not in already_processed:
            already_processed.add('lastName')
            outfile.write(' lastName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.lastName), input_name='lastName')),))
        if self.bornOn is not None and 'bornOn' not in already_processed:
            already_processed.add('bornOn')
            outfile.write(' bornOn=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bornOn), input_name='bornOn')),))
        if self.preferredLocale is not None and 'preferredLocale' not in already_processed:
            already_processed.add('preferredLocale')
            outfile.write(' preferredLocale=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.preferredLocale), input_name='preferredLocale')),))
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            outfile.write(' uuid=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.uuid), input_name='uuid')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MyDigiPassProfile', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('updatedAt', node)
        if value is not None and 'updatedAt' not in already_processed:
            already_processed.add('updatedAt')
            self.updatedAt = value
        value = find_attr_value_('firstName', node)
        if value is not None and 'firstName' not in already_processed:
            already_processed.add('firstName')
            self.firstName = value
        value = find_attr_value_('lastName', node)
        if value is not None and 'lastName' not in already_processed:
            already_processed.add('lastName')
            self.lastName = value
        value = find_attr_value_('bornOn', node)
        if value is not None and 'bornOn' not in already_processed:
            already_processed.add('bornOn')
            self.bornOn = value
        value = find_attr_value_('preferredLocale', node)
        if value is not None and 'preferredLocale' not in already_processed:
            already_processed.add('preferredLocale')
            self.preferredLocale = value
        value = find_attr_value_('uuid', node)
        if value is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            self.uuid = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MyDigiPassProfile


class MyDigiPassAddress(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, address1=None, address2=None, city=None, zip=None, country=None, state=None):
        self.original_tagname_ = None
        self.address1 = _cast(None, address1)
        self.address2 = _cast(None, address2)
        self.city = _cast(None, city)
        self.zip = _cast(None, zip)
        self.country = _cast(None, country)
        self.state = _cast(None, state)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MyDigiPassAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MyDigiPassAddress.subclass:
            return MyDigiPassAddress.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassAddress(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_address1(self): return self.address1

    def set_address1(self, address1): self.address1 = address1

    def get_address2(self): return self.address2

    def set_address2(self, address2): self.address2 = address2

    def get_city(self): return self.city

    def set_city(self, city): self.city = city

    def get_zip(self): return self.zip

    def set_zip(self, zip): self.zip = zip

    def get_country(self): return self.country

    def set_country(self, country): self.country = country

    def get_state(self): return self.state

    def set_state(self, state): self.state = state

    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MyDigiPassAddress', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MyDigiPassAddress')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MyDigiPassAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MyDigiPassAddress', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MyDigiPassAddress'):
        if self.address1 is not None and 'address1' not in already_processed:
            already_processed.add('address1')
            outfile.write(' address1=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.address1), input_name='address1')),))
        if self.address2 is not None and 'address2' not in already_processed:
            already_processed.add('address2')
            outfile.write(' address2=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.address2), input_name='address2')),))
        if self.city is not None and 'city' not in already_processed:
            already_processed.add('city')
            outfile.write(' city=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.city), input_name='city')),))
        if self.zip is not None and 'zip' not in already_processed:
            already_processed.add('zip')
            outfile.write(' zip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.zip), input_name='zip')),))
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            outfile.write(' country=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.country), input_name='country')),))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MyDigiPassAddress', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('address1', node)
        if value is not None and 'address1' not in already_processed:
            already_processed.add('address1')
            self.address1 = value
        value = find_attr_value_('address2', node)
        if value is not None and 'address2' not in already_processed:
            already_processed.add('address2')
            self.address2 = value
        value = find_attr_value_('city', node)
        if value is not None and 'city' not in already_processed:
            already_processed.add('city')
            self.city = value
        value = find_attr_value_('zip', node)
        if value is not None and 'zip' not in already_processed:
            already_processed.add('zip')
            self.zip = value
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.add('country')
            self.country = value
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MyDigiPassAddress


class MyDigiPassWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, eidPhoto=None, email=None, phone=None, eidProfile=None, eidAddress=None, profile=None, address=None):
        self.original_tagname_ = None
        super(MyDigiPassWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton,)
        self.eidPhoto = _cast(None, eidPhoto)
        self.email = _cast(None, email)
        self.phone = _cast(None, phone)
        self.eidProfile = eidProfile
        self.eidAddress = eidAddress
        self.profile = profile
        self.address = address

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MyDigiPassWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MyDigiPassWidgetStep.subclass:
            return MyDigiPassWidgetStep.subclass(*args_, **kwargs_)
        else:
            return MyDigiPassWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_eidProfile(self): return self.eidProfile

    def set_eidProfile(self, eidProfile): self.eidProfile = eidProfile

    def get_eidAddress(self): return self.eidAddress

    def set_eidAddress(self, eidAddress): self.eidAddress = eidAddress

    def get_profile(self): return self.profile

    def set_profile(self, profile): self.profile = profile

    def get_address(self): return self.address

    def set_address(self, address): self.address = address

    def get_eidPhoto(self): return self.eidPhoto

    def set_eidPhoto(self, eidPhoto): self.eidPhoto = eidPhoto

    def get_email(self): return self.email

    def set_email(self, email): self.email = email

    def get_phone(self): return self.phone

    def set_phone(self, phone): self.phone = phone

    def hasContent_(self):
        if (
            self.eidProfile is not None or
            self.eidAddress is not None or
            self.profile is not None or
            self.address is not None or
            super(MyDigiPassWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MyDigiPassWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MyDigiPassWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MyDigiPassWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MyDigiPassWidgetStep', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MyDigiPassWidgetStep'):
        super(MyDigiPassWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MyDigiPassWidgetStep')
        if self.eidPhoto is not None and 'eidPhoto' not in already_processed:
            already_processed.add('eidPhoto')
            outfile.write(' eidPhoto=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.eidPhoto), input_name='eidPhoto')),))
        if self.email is not None and 'email' not in already_processed:
            already_processed.add('email')
            outfile.write(' email=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.email), input_name='email')),))
        if self.phone is not None and 'phone' not in already_processed:
            already_processed.add('phone')
            outfile.write(' phone=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.phone), input_name='phone')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MyDigiPassWidgetStep', fromsubclass_=False, pretty_print=True):
        super(MyDigiPassWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.eidProfile is not None:
            self.eidProfile.export(outfile, level, namespaceprefix_, name_='eidProfile', pretty_print=pretty_print)
        if self.eidAddress is not None:
            self.eidAddress.export(outfile, level, namespaceprefix_, name_='eidAddress', pretty_print=pretty_print)
        if self.profile is not None:
            self.profile.export(outfile, level, namespaceprefix_, name_='profile', pretty_print=pretty_print)
        if self.address is not None:
            self.address.export(outfile, level, namespaceprefix_, name_='address', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('eidPhoto', node)
        if value is not None and 'eidPhoto' not in already_processed:
            already_processed.add('eidPhoto')
            self.eidPhoto = value
        value = find_attr_value_('email', node)
        if value is not None and 'email' not in already_processed:
            already_processed.add('email')
            self.email = value
        value = find_attr_value_('phone', node)
        if value is not None and 'phone' not in already_processed:
            already_processed.add('phone')
            self.phone = value
        super(MyDigiPassWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'eidProfile':
            obj_ = MyDigiPassEidProfile.factory()
            obj_.build(child_)
            self.eidProfile = obj_
            obj_.original_tagname_ = 'eidProfile'
        elif nodeName_ == 'eidAddress':
            obj_ = MyDigiPassEidAddress.factory()
            obj_.build(child_)
            self.eidAddress = obj_
            obj_.original_tagname_ = 'eidAddress'
        elif nodeName_ == 'profile':
            obj_ = MyDigiPassProfile.factory()
            obj_.build(child_)
            self.profile = obj_
            obj_.original_tagname_ = 'profile'
        elif nodeName_ == 'address':
            obj_ = MyDigiPassAddress.factory()
            obj_.build(child_)
            self.address = obj_
            obj_.original_tagname_ = 'address'
        super(MyDigiPassWidgetStep, self).buildChildren(child_, node, nodeName_, True)
# end class MyDigiPassWidgetStep


class SelectSingleWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, value=None):
        self.original_tagname_ = None
        super(SelectSingleWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton,)
        self.value = _cast(None, value)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectSingleWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectSingleWidgetStep.subclass:
            return SelectSingleWidgetStep.subclass(*args_, **kwargs_)
        else:
            return SelectSingleWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_value(self): return self.value

    def set_value(self, value): self.value = value

    def hasContent_(self):
        if (
            super(SelectSingleWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SelectSingleWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectSingleWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectSingleWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SelectSingleWidgetStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelectSingleWidgetStep'):
        super(SelectSingleWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectSingleWidgetStep')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SelectSingleWidgetStep', fromsubclass_=False, pretty_print=True):
        super(SelectSingleWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(SelectSingleWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelectSingleWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelectSingleWidgetStep


class SelectMultiWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, selection=None):
        self.original_tagname_ = None
        super(SelectMultiWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton,)
        if selection is None:
            self.selection = []
        else:
            self.selection = selection

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectMultiWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectMultiWidgetStep.subclass:
            return SelectMultiWidgetStep.subclass(*args_, **kwargs_)
        else:
            return SelectMultiWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_selection(self): return self.selection

    def set_selection(self, selection): self.selection = selection

    def add_selection(self, value): self.selection.append(value)

    def insert_selection_at(self, index, value): self.selection.insert(index, value)

    def replace_selection_at(self, index, value): self.selection[index] = value

    def hasContent_(self):
        if (
            self.selection or
            super(SelectMultiWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SelectMultiWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectMultiWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectMultiWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SelectMultiWidgetStep', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelectMultiWidgetStep'):
        super(SelectMultiWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectMultiWidgetStep')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SelectMultiWidgetStep', fromsubclass_=False, pretty_print=True):
        super(SelectMultiWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for selection_ in self.selection:
            selection_.export(outfile, level, namespaceprefix_, name_='selection', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(SelectMultiWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'selection':
            class_obj_ = self.get_class_obj_(child_, Value)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.selection.append(obj_)
            obj_.original_tagname_ = 'selection'
        super(SelectMultiWidgetStep, self).buildChildren(child_, node, nodeName_, True)
# end class SelectMultiWidgetStep


class SelectDateWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, date=None):
        self.original_tagname_ = None
        super(SelectDateWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton,)
        self.date = _cast(int, date)

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectDateWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectDateWidgetStep.subclass:
            return SelectDateWidgetStep.subclass(*args_, **kwargs_)
        else:
            return SelectDateWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_date(self): return self.date

    def set_date(self, date): self.date = date

    def hasContent_(self):
        if (
            super(SelectDateWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SelectDateWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectDateWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectDateWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SelectDateWidgetStep', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelectDateWidgetStep'):
        super(SelectDateWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectDateWidgetStep')
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date="%s"' % self.gds_format_integer(self.date, input_name='date'))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SelectDateWidgetStep', fromsubclass_=False, pretty_print=True):
        super(SelectDateWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            try:
                self.date = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(SelectDateWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelectDateWidgetStep, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelectDateWidgetStep


class SelectFriendWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, selection=None):
        self.original_tagname_ = None
        super(SelectFriendWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton,)
        if selection is None:
            self.selection = []
        else:
            self.selection = selection

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelectFriendWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelectFriendWidgetStep.subclass:
            return SelectFriendWidgetStep.subclass(*args_, **kwargs_)
        else:
            return SelectFriendWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_selection(self): return self.selection

    def set_selection(self, selection): self.selection = selection

    def add_selection(self, value): self.selection.append(value)

    def insert_selection_at(self, index, value): self.selection.insert(index, value)

    def replace_selection_at(self, index, value): self.selection[index] = value

    def hasContent_(self):
        if (
            self.selection or
            super(SelectFriendWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='SelectFriendWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelectFriendWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectFriendWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='SelectFriendWidgetStep', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelectFriendWidgetStep'):
        super(SelectFriendWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelectFriendWidgetStep')

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SelectFriendWidgetStep', fromsubclass_=False, pretty_print=True):
        super(SelectFriendWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for selection_ in self.selection:
            selection_.export(outfile, level, namespaceprefix_, name_='selection', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        super(SelectFriendWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'selection':
            class_obj_ = self.get_class_obj_(child_, Value)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.selection.append(obj_)
            obj_.original_tagname_ = 'selection'
        super(SelectFriendWidgetStep, self).buildChildren(child_, node, nodeName_, True)
# end class SelectFriendWidgetStep


class AdvancedOrderWidgetStep(WidgetStep):
    subclass = None
    superclass = WidgetStep

    def __init__(self, id=None, creationTimestamp=None, definition=None, previousStep=None, nextStep=None, message=None, button=None, receivedTimestamp=None, acknowledgedTimestamp=None, displayValue=None, formButton=None, currency=None, category=None):
        self.original_tagname_ = None
        super(AdvancedOrderWidgetStep, self).__init__(id, creationTimestamp, definition, previousStep, nextStep, message, button, receivedTimestamp, acknowledgedTimestamp, displayValue, formButton,)
        self.currency = _cast(None, currency)
        if category is None:
            self.category = []
        else:
            self.category = category

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AdvancedOrderWidgetStep)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AdvancedOrderWidgetStep.subclass:
            return AdvancedOrderWidgetStep.subclass(*args_, **kwargs_)
        else:
            return AdvancedOrderWidgetStep(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_category(self): return self.category

    def set_category(self, category): self.category = category

    def add_category(self, value): self.category.append(value)

    def insert_category_at(self, index, value): self.category.insert(index, value)

    def replace_category_at(self, index, value): self.category[index] = value

    def get_currency(self): return self.currency

    def set_currency(self, currency): self.currency = currency

    def hasContent_(self):
        if (
            self.category or
            super(AdvancedOrderWidgetStep, self).hasContent_()
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='AdvancedOrderWidgetStep', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AdvancedOrderWidgetStep')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdvancedOrderWidgetStep')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='AdvancedOrderWidgetStep', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AdvancedOrderWidgetStep'):
        super(AdvancedOrderWidgetStep, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AdvancedOrderWidgetStep')
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            outfile.write(' currency=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.currency), input_name='currency')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='AdvancedOrderWidgetStep', fromsubclass_=False, pretty_print=True):
        super(AdvancedOrderWidgetStep, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for category_ in self.category:
            category_.export(outfile, level, namespaceprefix_, name_='category', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.add('currency')
            self.currency = value
        super(AdvancedOrderWidgetStep, self).buildAttributes(node, attrs, already_processed)

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'category':
            obj_ = AdvancedOrderCategory.factory()
            obj_.build(child_)
            self.category.append(obj_)
            obj_.original_tagname_ = 'category'
        super(AdvancedOrderWidgetStep, self).buildChildren(child_, node, nodeName_, True)
# end class AdvancedOrderWidgetStep


class MemberRun(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, email=None, name=None, status=None, endReference=None, language=None, appId=None, avatarUrl=None, userData=None, step=None):
        self.original_tagname_ = None
        self.email = _cast(None, email)
        self.name = _cast(None, name)
        self.status = _cast(None, status)
        self.endReference = _cast(None, endReference)
        self.language = _cast(None, language)
        self.appId = _cast(None, appId)
        self.avatarUrl = _cast(None, avatarUrl)
        self.userData = _cast(None, userData)
        if step is None:
            self.step = []
        else:
            self.step = step

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemberRun)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemberRun.subclass:
            return MemberRun.subclass(*args_, **kwargs_)
        else:
            return MemberRun(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_step(self): return self.step

    def set_step(self, step): self.step = step

    def add_step(self, value): self.step.append(value)

    def insert_step_at(self, index, value): self.step.insert(index, value)

    def replace_step_at(self, index, value): self.step[index] = value

    def get_email(self): return self.email

    def set_email(self, email): self.email = email

    def get_name(self): return self.name

    def set_name(self, name): self.name = name

    def get_status(self): return self.status

    def set_status(self, status): self.status = status

    def get_endReference(self): return self.endReference

    def set_endReference(self, endReference): self.endReference = endReference

    def get_language(self): return self.language

    def set_language(self, language): self.language = language

    def get_appId(self): return self.appId

    def set_appId(self, appId): self.appId = appId

    def get_avatarUrl(self): return self.avatarUrl

    def set_avatarUrl(self, avatarUrl): self.avatarUrl = avatarUrl

    def get_userData(self): return self.userData

    def set_userData(self, userData): self.userData = userData

    def validate_MemberStatus(self, value):
        # Validate type MemberStatus, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['SUBMITTED', 'INITIATED', 'RUNNING', 'FINISHED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on MemberStatus' % {"value" : value.encode("utf-8")})

    def hasContent_(self):
        if (
            self.step
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MemberRun', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MemberRun')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MemberRun')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MemberRun', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MemberRun'):
        if self.email is not None and 'email' not in already_processed:
            already_processed.add('email')
            outfile.write(' email=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.email), input_name='email')),))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')),))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (quote_attrib(self.status),))
        if self.endReference is not None and 'endReference' not in already_processed:
            already_processed.add('endReference')
            outfile.write(' endReference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.endReference), input_name='endReference')),))
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.language), input_name='language')),))
        if self.appId is not None and 'appId' not in already_processed:
            already_processed.add('appId')
            outfile.write(' appId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.appId), input_name='appId')),))
        if self.avatarUrl is not None and 'avatarUrl' not in already_processed:
            already_processed.add('avatarUrl')
            outfile.write(' avatarUrl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.avatarUrl), input_name='avatarUrl')),))
        if self.userData is not None and 'userData' not in already_processed:
            already_processed.add('userData')
            outfile.write(' userData=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.userData), input_name='userData')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MemberRun', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for step_ in self.step:
            step_.export(outfile, level, namespaceprefix_, name_='step', pretty_print=pretty_print)

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('email', node)
        if value is not None and 'email' not in already_processed:
            already_processed.add('email')
            self.email = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
            self.validate_MemberStatus(self.status)  # validate type MemberStatus
        value = find_attr_value_('endReference', node)
        if value is not None and 'endReference' not in already_processed:
            already_processed.add('endReference')
            self.endReference = value
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
        value = find_attr_value_('appId', node)
        if value is not None and 'appId' not in already_processed:
            already_processed.add('appId')
            self.appId = value
        value = find_attr_value_('avatarUrl', node)
        if value is not None and 'avatarUrl' not in already_processed:
            already_processed.add('avatarUrl')
            self.avatarUrl = value
        value = find_attr_value_('userData', node)
        if value is not None and 'userData' not in already_processed:
            already_processed.add('userData')
            self.userData = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'step':
            class_obj_ = self.get_class_obj_(child_, Step)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
# end class MemberRun


class MessageFlowRun(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, launchTimestamp=None, serviceName=None, serviceDisplayEmail=None, serviceEmail=None, serviceData=None, definition=None, memberRun=None, flowParams=None):
        self.original_tagname_ = None
        self.launchTimestamp = _cast(int, launchTimestamp)
        self.serviceName = _cast(None, serviceName)
        self.serviceDisplayEmail = _cast(None, serviceDisplayEmail)
        self.serviceEmail = _cast(None, serviceEmail)
        self.serviceData = _cast(None, serviceData)
        if definition is None:
            self.definition = []
        else:
            self.definition = definition
        if memberRun is None:
            self.memberRun = []
        else:
            self.memberRun = memberRun
        self.flowParams = flowParams

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageFlowRun)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageFlowRun.subclass:
            return MessageFlowRun.subclass(*args_, **kwargs_)
        else:
            return MessageFlowRun(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_definition(self): return self.definition

    def set_definition(self, definition): self.definition = definition

    def add_definition(self, value): self.definition.append(value)

    def insert_definition_at(self, index, value): self.definition.insert(index, value)

    def replace_definition_at(self, index, value): self.definition[index] = value

    def get_memberRun(self): return self.memberRun

    def set_memberRun(self, memberRun): self.memberRun = memberRun

    def add_memberRun(self, value): self.memberRun.append(value)

    def insert_memberRun_at(self, index, value): self.memberRun.insert(index, value)

    def replace_memberRun_at(self, index, value): self.memberRun[index] = value

    def get_flowParams(self): return self.flowParams

    def set_flowParams(self, flowParams): self.flowParams = flowParams

    def get_launchTimestamp(self): return self.launchTimestamp

    def set_launchTimestamp(self, launchTimestamp): self.launchTimestamp = launchTimestamp

    def get_serviceName(self): return self.serviceName

    def set_serviceName(self, serviceName): self.serviceName = serviceName

    def get_serviceDisplayEmail(self): return self.serviceDisplayEmail

    def set_serviceDisplayEmail(self, serviceDisplayEmail): self.serviceDisplayEmail = serviceDisplayEmail

    def get_serviceEmail(self): return self.serviceEmail

    def set_serviceEmail(self, serviceEmail): self.serviceEmail = serviceEmail

    def get_serviceData(self): return self.serviceData

    def set_serviceData(self, serviceData): self.serviceData = serviceData

    def hasContent_(self):
        if (
            self.definition or
            self.memberRun or
            self.flowParams is not None
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='MessageFlowRun', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessageFlowRun')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessageFlowRun')
        if self.hasContent_():
            outfile.write('>%s' % (eol_,))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='MessageFlowRun', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessageFlowRun'):
        if self.launchTimestamp is not None and 'launchTimestamp' not in already_processed:
            already_processed.add('launchTimestamp')
            outfile.write(' launchTimestamp="%s"' % self.gds_format_integer(self.launchTimestamp, input_name='launchTimestamp'))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            outfile.write(' serviceName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceName), input_name='serviceName')),))
        if self.serviceDisplayEmail is not None and 'serviceDisplayEmail' not in already_processed:
            already_processed.add('serviceDisplayEmail')
            outfile.write(' serviceDisplayEmail=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceDisplayEmail), input_name='serviceDisplayEmail')),))
        if self.serviceEmail is not None and 'serviceEmail' not in already_processed:
            already_processed.add('serviceEmail')
            outfile.write(' serviceEmail=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceEmail), input_name='serviceEmail')),))
        if self.serviceData is not None and 'serviceData' not in already_processed:
            already_processed.add('serviceData')
            outfile.write(' serviceData=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.serviceData), input_name='serviceData')),))

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MessageFlowRun', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for definition_ in self.definition:
            definition_.export(outfile, level, namespaceprefix_, name_='definition', pretty_print=pretty_print)
        for memberRun_ in self.memberRun:
            memberRun_.export(outfile, level, namespaceprefix_, name_='memberRun', pretty_print=pretty_print)
        if self.flowParams is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<flowParams>%s</flowParams>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.flowParams), input_name='flowParams')), eol_))

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('launchTimestamp', node)
        if value is not None and 'launchTimestamp' not in already_processed:
            already_processed.add('launchTimestamp')
            try:
                self.launchTimestamp = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('serviceName', node)
        if value is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            self.serviceName = value
        value = find_attr_value_('serviceDisplayEmail', node)
        if value is not None and 'serviceDisplayEmail' not in already_processed:
            already_processed.add('serviceDisplayEmail')
            self.serviceDisplayEmail = value
        value = find_attr_value_('serviceEmail', node)
        if value is not None and 'serviceEmail' not in already_processed:
            already_processed.add('serviceEmail')
            self.serviceEmail = value
        value = find_attr_value_('serviceData', node)
        if value is not None and 'serviceData' not in already_processed:
            already_processed.add('serviceData')
            self.serviceData = value

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'definition':
            obj_ = MessageFlowDefinition.factory()
            obj_.build(child_)
            self.definition.append(obj_)
            obj_.original_tagname_ = 'definition'
        elif nodeName_ == 'memberRun':
            obj_ = MemberRun.factory()
            obj_.build(child_)
            self.memberRun.append(obj_)
            obj_.original_tagname_ = 'memberRun'
        elif nodeName_ == 'flowParams':
            flowParams_ = child_.text
            flowParams_ = self.gds_validate_string(flowParams_, node, 'flowParams')
            self.flowParams = flowParams_
# end class MessageFlowRun


class contentType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contentType.subclass:
            return contentType.subclass(*args_, **kwargs_)
        else:
            return contentType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_valueOf_(self): return self.valueOf_

    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='contentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('contentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='contentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='contentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='contentType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='contentType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contentType


class javascriptCodeType(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, javascriptCodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if javascriptCodeType.subclass:
            return javascriptCodeType.subclass(*args_, **kwargs_)
        else:
            return javascriptCodeType(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_valueOf_(self): return self.valueOf_

    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='javascriptCodeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('javascriptCodeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='javascriptCodeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='javascriptCodeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='javascriptCodeType'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='javascriptCodeType', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class javascriptCodeType


class contentType1(GeneratedsSuper):
    subclass = None
    superclass = None

    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, contentType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if contentType1.subclass:
            return contentType1.subclass(*args_, **kwargs_)
        else:
            return contentType1(*args_, **kwargs_)

    factory = staticmethod(factory)

    def get_valueOf_(self): return self.valueOf_

    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_

    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int, float] else self.valueOf_)
        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespaceprefix_='', name_='contentType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('contentType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '',))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='contentType1')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_='', name_='contentType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_,))

    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='contentType1'):
        pass

    def exportChildren(self, outfile, level, namespaceprefix_='', name_='contentType1', fromsubclass_=False, pretty_print=True):
        pass

    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self

    def buildAttributes(self, node, attrs, already_processed):
        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contentType1


GDSClassesMapping = {
    'messageFlowDefinition': MessageFlowDefinition,
    'messageFlowDefinitionSet': MessageFlowDefinitionSet,
    'messageFlowRun': MessageFlowRun,
}

USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attachment'
        rootClass = Attachment
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attachment'
        rootClass = Attachment
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode = parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attachment'
        rootClass = Attachment
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Attachment'
        rootClass = Attachment
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from gen import *\n\n')
        sys.stdout.write('import gen as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    # import pdb; pdb.set_trace()
    main()

__all__ = [
    "AdvancedOrderCategory",
    "AdvancedOrderItem",
    "AdvancedOrderWidget",
    "AdvancedOrderWidgetStep",
    "Answer",
    "Attachment",
    "BaseMessageStep",
    "BasePaymentMethod",
    "BaseSliderWidget",
    "Choice",
    "End",
    "FloatValue",
    "FlowCode",
    "FlowElement",
    "Form",
    "FormMessage",
    "GPSLocationWidget",
    "GPSLocationWidgetStep",
    "MemberRun",
    "Message",
    "MessageFlowDefinition",
    "MessageFlowDefinitionSet",
    "MessageFlowRun",
    "MessageStep",
    "MyDigiPassAddress",
    "MyDigiPassEidAddress",
    "MyDigiPassEidProfile",
    "MyDigiPassProfile",
    "MyDigiPassWidget",
    "MyDigiPassWidgetStep",
    "OauthWidget",
    "Outlet",
    "PayWidget",
    "PaymentMethod",
    "PhotoUploadWidget",
    "PhotoUploadWidgetStep",
    "RangeSliderWidget",
    "RangeSliderWidgetStep",
    "ResultsEmail",
    "ResultsFlush",
    "SelectDateWidget",
    "SelectDateWidgetStep",
    "SelectFriendWidget",
    "SelectFriendWidgetStep",
    "SelectMultiWidget",
    "SelectMultiWidgetStep",
    "SelectSingleWidget",
    "SelectSingleWidgetStep",
    "SelectWidget",
    "SignWidget",
    "SliderWidget",
    "SliderWidgetStep",
    "Step",
    "TextAutoCompleteWidgetStep",
    "TextAutocompleteWidget",
    "TextBlockWidget",
    "TextBlockWidgetStep",
    "TextLineWidget",
    "TextLineWidgetStep",
    "TextWidget",
    "TextWidgetStep",
    "Value",
    "Widget",
    "WidgetStep",
    "contentType",
    "contentType1",
    "javascriptCodeType"
]
